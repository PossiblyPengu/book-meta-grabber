<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Book Meta Grabber</title>
  
  <style>
    /* ===== MODERN DESIGN SYSTEM ===== */
    
    :root {
      /* Colors */
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #818cf8;
      --secondary: #8b5cf6;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      
      /* Neutrals */
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --surface: #1e293b;
      --surface-elevated: #334155;
      
      /* Text */
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --text-muted: #94a3b8;
      --text-dim: #64748b;
      
      /* Borders */
      --border: rgba(255, 255, 255, 0.1);
      --border-focus: var(--primary);
      
      /* Safe Areas */
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      
      /* Spacing */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      
      /* Touch Targets */
      --touch-min: 44px;
      --touch-comfortable: 48px;
      
      /* Typography */
      --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
      
      /* Shadows */
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
      
      /* Transitions */
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 250ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Border Radius */
      --radius-sm: 6px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;
      --radius-full: 9999px;
    }
    
    /* ===== BASE STYLES ===== */
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html {
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    
    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    /* ===== LAYOUT COMPONENTS ===== */
    
    .app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding-top: var(--safe-top);
      padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left);
      padding-right: var(--safe-right);
    }
    
    .header {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md);
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    
    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 100%;
    }
    
    .title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
    }
    
    .header-actions {
      display: flex;
      gap: var(--spacing-sm);
    }
    
    .main {
      flex: 1;
      padding: var(--spacing-md);
      overflow-y: auto;
    }
    
    .tab-bar {
      background: var(--surface);
      border-top: 1px solid var(--border);
      display: flex;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 100;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    
    .tab-button {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm);
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      min-height: var(--touch-comfortable);
      transition: all var(--transition-fast);
      position: relative;
    }
    
    .tab-button:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.05);
    }
    
    .tab-button.active {
      color: var(--primary);
    }
    
    .tab-button.active::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 32px;
      height: 3px;
      background: var(--primary);
      border-radius: var(--radius-full);
    }
    
    .tab-icon {
      width: 24px;
      height: 24px;
    }
    
    .tab-label {
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    /* ===== TAB SCREENS ===== */
    
    .tab-screen {
      display: none;
      padding-bottom: 80px; /* Space for tab bar */
    }
    
    .tab-screen.active {
      display: block;
    }
    
    /* ===== BUTTONS ===== */
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--surface);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      min-height: var(--touch-min);
      transition: all var(--transition-fast);
      text-decoration: none;
    }
    
    .btn:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
      transform: translateY(-1px);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    
    .btn-primary:hover {
      background: var(--primary-dark);
      border-color: var(--primary-dark);
    }
    
    .btn-icon {
      padding: var(--spacing-sm);
      aspect-ratio: 1;
    }
    
    /* ===== BOOK GRID ===== */
    
    .book-grid {
      display: grid;
      gap: var(--spacing-md);
      grid-template-columns: 1fr;
    }
    
    .book-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      display: flex;
      gap: var(--spacing-md);
      cursor: pointer;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .book-card:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .book-cover {
      width: 60px;
      height: 80px;
      border-radius: var(--radius-md);
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    
    .book-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .book-info {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    .book-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--spacing-xs);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .book-author {
      color: var(--text-secondary);
      font-size: 0.875rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .book-format {
      position: absolute;
      top: var(--spacing-sm);
      right: var(--spacing-sm);
      background: var(--primary);
      color: white;
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      font-size: 0.625rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .book-progress-indicator {
      position: absolute;
      bottom: var(--spacing-xs);
      right: var(--spacing-xs);
      background: var(--success);
      color: white;
      padding: 2px 6px;
      border-radius: var(--radius-full);
      font-size: 0.625rem;
      font-weight: 600;
    }

    .book-status {
      margin-top: var(--spacing-xs);
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-weight: 500;
    }
    
    /* ===== FILTER BAR ===== */
    
    .filter-bar {
      display: flex;
      gap: var(--spacing-sm);
      padding: var(--spacing-md);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    .filter-bar::-webkit-scrollbar {
      display: none;
    }
    
    .filter-chip {
      display: inline-flex;
      align-items: center;
      padding: var(--spacing-xs) var(--spacing-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-full);
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
      transition: all var(--transition-fast);
    }
    
    .filter-chip:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
      color: var(--text-primary);
    }
    
    .filter-chip.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    /* ===== BATCH OPERATIONS ===== */
    
    .batch-actions {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md);
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .batch-info {
      flex: 1;
      font-weight: 500;
      color: var(--text-primary);
    }

    .batch-buttons {
      display: flex;
      gap: var(--spacing-sm);
    }

    .book-card {
      position: relative;
    }

    .book-card.select-mode {
      cursor: pointer;
    }

    .book-card.select-mode::before {
      content: '';
      position: absolute;
      top: var(--spacing-sm);
      left: var(--spacing-sm);
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--surface);
      z-index: 10;
      transition: all var(--transition-fast);
    }

    .book-card.select-mode.selected::before {
      background: var(--primary);
      border-color: var(--primary);
    }

    .book-card.select-mode.selected::after {
      content: '✓';
      position: absolute;
      top: var(--spacing-sm);
      left: var(--spacing-sm);
      width: 20px;
      height: 20px;
      color: white;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 11;
    }
    
    /* ===== EMPTY STATE ===== */
    
    .empty-state {
      text-align: center;
      padding: var(--spacing-xl) var(--spacing-md);
      color: var(--text-muted);
    }
    
    .empty-icon {
      width: 64px;
      height: 64px;
      margin: 0 auto var(--spacing-md);
      opacity: 0.5;
    }
    
    .empty-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: var(--spacing-sm);
      color: var(--text-secondary);
    }
    
    .empty-description {
      margin-bottom: var(--spacing-lg);
      line-height: 1.6;
    }
    
    /* ===== RESPONSIVE DESIGN ===== */
    
    @media (min-width: 768px) {
      .book-grid {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
      
      .book-card {
        flex-direction: column;
        text-align: center;
      }
      
      .book-cover {
        width: 120px;
        height: 160px;
        margin: 0 auto var(--spacing-md);
      }
      
      .book-info {
        text-align: center;
      }
    }
    
    @media (min-width: 1024px) {
      .main {
        max-width: 1200px;
        margin: 0 auto;
      }
      
      .book-grid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      }
    }
    
    /* ===== ACCESSIBILITY ===== */
    
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    
    /* ===== UTILITIES ===== */
    
    .text-center { text-align: center; }
    .mt-sm { margin-top: var(--spacing-sm); }
    .mt-md { margin-top: var(--spacing-md); }
    .mt-lg { margin-top: var(--spacing-lg); }

    /* ===== THEME TOGGLE ===== */
    .theme-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .theme-btn:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
      color: var(--text-primary);
    }

    .theme-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .theme-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Light theme overrides */
    [data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;
      --surface: #ffffff;
      --surface-elevated: #f8fafc;
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --text-dim: #94a3b8;
      --border: rgba(0, 0, 0, 0.1);
      --border-focus: var(--primary);
    }

    [data-theme="light"] .editor-backdrop {
      background: rgba(0, 0, 0, 0.5);
    }

    [data-theme="light"] .editor-hero-overlay {
      background: linear-gradient(to bottom, 
        rgba(255, 255, 255, 0.95) 0%, 
        rgba(255, 255, 255, 0.85) 50%, 
        rgba(255, 255, 255, 0.95) 100%
      );
    }

    /* ===== METADATA EDITOR ===== */
    .editor-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      display: none;
    }

    .editor-modal.active {
      display: block;
    }

    .editor-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .editor-sheet {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      transform: translateY(100%);
      transition: transform var(--transition-slow) cubic-bezier(0.34, 1.2, 0.64, 1);
    }

    .editor-modal.active .editor-sheet {
      transform: translateY(0);
    }

    .editor-hero {
      position: relative;
      height: 300px;
      background: var(--surface);
      overflow: hidden;
    }

    .editor-cover-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-md);
    }

    .editor-cover {
      width: 120px;
      height: 160px;
      border-radius: var(--radius-md);
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      position: relative;
    }

    .editor-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .editor-cover-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      color: var(--text-muted);
    }

    .editor-cover-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .editor-cover-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .editor-cover-btn:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
    }

    .editor-cover-btn svg {
      width: 16px;
      height: 16px;
    }

    .editor-hero-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, 
        rgba(15, 23, 42, 0.9) 0%, 
        rgba(15, 23, 42, 0.7) 50%, 
        rgba(15, 23, 42, 0.95) 100%
      );
    }

    .editor-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
      padding-top: calc(var(--spacing-md) + 60px); /* Space for header */
    }

    .editor-header {
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md);
      margin: calc(-60px - var(--spacing-md)) -var(--spacing-md) var(--spacing-md) -var(--spacing-md);
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 10;
    }

    .editor-close-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: var(--radius-md);
      transition: all var(--transition-fast);
    }

    .editor-close-btn:hover {
      background: var(--surface);
      color: var(--text-primary);
    }

    .editor-close-btn svg {
      width: 20px;
      height: 20px;
    }

    .editor-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .editor-actions {
      display: flex;
      gap: var(--spacing-sm);
    }

    .editor-search-results {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-md);
      max-height: 300px;
      overflow-y: auto;
    }

    .editor-search-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--border);
    }

    .editor-search-header h3 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .editor-search-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-md);
      transition: all var(--transition-fast);
    }

    .editor-search-close:hover {
      background: var(--surface-elevated);
      color: var(--text-primary);
    }

    .editor-search-list {
      padding: var(--spacing-sm);
    }

    .editor-search-item {
      display: flex;
      gap: var(--spacing-md);
      padding: var(--spacing-sm);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .editor-search-item:hover {
      background: var(--surface-elevated);
    }

    .editor-search-item-cover {
      width: 40px;
      height: 60px;
      border-radius: var(--radius-sm);
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }

    .editor-search-item-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .editor-search-item-info {
      flex: 1;
      min-width: 0;
    }

    .editor-search-item-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--spacing-xs);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .editor-search-item-author {
      color: var(--text-secondary);
      font-size: 0.875rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .editor-form {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .editor-form-group {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-xs);
    }

    .editor-form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
    }

    .editor-label {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .editor-input,
    .editor-select,
    .editor-textarea {
      padding: var(--spacing-sm);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--surface);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.875rem;
      transition: all var(--transition-fast);
    }

    .editor-input:focus,
    .editor-select:focus,
    .editor-textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .editor-textarea {
      resize: vertical;
      min-height: 100px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .editor-form-row {
        grid-template-columns: 1fr;
      }
      
      .editor-hero {
        height: 250px;
      }
      
      .editor-cover {
        width: 100px;
        height: 133px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="header-content">
        <h1 class="title">Book Meta Grabber</h1>
        <div class="header-actions">
          <button class="btn btn-icon" id="searchBtn" aria-label="Search">
            <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"/>
              <path d="m21 21-4.35-4.35"/>
            </svg>
          </button>
          <button class="btn btn-icon" id="addBtn" aria-label="Add Book">
            <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="5" x2="12" y2="19"/>
              <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
          </button>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Library Tab -->
      <div class="tab-screen active" id="libraryTab">
        <!-- Batch Actions Bar -->
        <div class="batch-actions" id="batchActions" style="display: none;">
          <div class="batch-info">
            <span id="selectedCount">0</span> books selected
          </div>
          <div class="batch-buttons">
            <button class="btn" id="batchEditBtn">Edit All</button>
            <button class="btn" id="batchExportBtn">Export</button>
            <button class="btn" id="batchDeleteBtn" style="color: var(--error); border-color: var(--error);">Delete</button>
          </div>
          <button class="btn btn-icon" id="batchCancelBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>

        <!-- Filter Bar -->
        <div class="filter-bar">
          <button class="filter-chip active" data-format="all">All</button>
          <button class="filter-chip" data-format="epub">EPUB</button>
          <button class="filter-chip" data-format="pdf">PDF</button>
          <button class="filter-chip" data-format="mp3">MP3</button>
          <button class="filter-chip" data-format="m4b">M4B</button>
          <button class="filter-chip" data-format="flac">FLAC</button>
          <button class="filter-chip" data-format="ogg">OGG</button>
          <button class="filter-chip" id="selectModeBtn">Select</button>
        </div>

        <!-- Book Grid -->
        <div class="book-grid" id="bookGrid">
          <!-- Books will be rendered here -->
        </div>

        <!-- Empty State -->
        <div class="empty-state" id="emptyState" style="display: none;">
          <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
          </svg>
          <h2 class="empty-title">No books yet</h2>
          <p class="empty-description">
            Tap the + button to add books from your device, iCloud Drive, or Google Drive.
          </p>
          <button class="btn btn-primary" id="emptyAddBtn">Add Your First Book</button>
        </div>
      </div>

      <!-- Search Tab -->
      <div class="tab-screen" id="searchTab">
        <div style="padding: var(--spacing-md);">
          <h2 style="margin-bottom: var(--spacing-md);">Search Metadata</h2>
          <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
            Search for book metadata from multiple sources including Google Books, Open Library, iTunes, and MusicBrainz.
          </p>
          <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-md);">
            <input 
              type="search" 
              id="searchInput"
              placeholder="Search by title, author, or ISBN..."
              style="flex: 1; padding: var(--spacing-sm); border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--surface); color: var(--text-primary);"
            >
            <button class="btn btn-primary" id="searchSubmitBtn">Search</button>
          </div>
          <div id="searchResults" style="margin-top: var(--spacing-md);">
            <!-- Search results will appear here -->
          </div>
        </div>
      </div>

      <!-- Settings Tab -->
      <div class="tab-screen" id="settingsTab">
        <div style="padding: var(--spacing-md);">
          <h2 style="margin-bottom: var(--spacing-lg);">Settings</h2>
          
          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Appearance</h3>
            <div style="display: flex; align-items: center; justify-content: space-between;">
              <label style="color: var(--text-secondary);">Theme</label>
              <div style="display: flex; gap: var(--spacing-sm);">
                <button class="theme-btn" id="lightThemeBtn" data-theme="light">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <line x1="12" y1="1" x2="12" y2="3"/>
                    <line x1="12" y1="21" x2="12" y2="23"/>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                    <line x1="1" y1="12" x2="3" y2="12"/>
                    <line x1="21" y1="12" x2="23" y2="12"/>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                  </svg>
                  Light
                </button>
                <button class="theme-btn" id="darkThemeBtn" data-theme="dark">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                  </svg>
                  Dark
                </button>
              </div>
            </div>
          </div>

          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Google Drive Integration</h3>
            <div style="margin-bottom: var(--spacing-sm);">
              <label style="display: block; margin-bottom: var(--spacing-xs); color: var(--text-secondary);">OAuth Client ID</label>
              <input 
                type="text" 
                id="gdriveInput"
                placeholder="Enter your Google OAuth Client ID"
                style="width: 100%; padding: var(--spacing-sm); border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--bg-primary); color: var(--text-primary);"
              >
            </div>
            <p style="font-size: 0.875rem; color: var(--text-muted);">
              Required for Google Drive integration. Create one at console.cloud.google.com
            </p>
          </div>

          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Library Management</h3>
            <div style="margin-bottom: var(--spacing-md);">
              <label style="display: block; margin-bottom: var(--spacing-xs); color: var(--text-secondary);">Export Format</label>
              <select id="exportFormat" style="width: 100%; padding: var(--spacing-sm); border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--bg-primary); color: var(--text-primary);">
                <option value="json">JSON</option>
                <option value="csv">CSV</option>
                <option value="pdf">PDF</option>
              </select>
            </div>
            <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-sm);">
              <button class="btn" id="exportBtn">Export Library</button>
              <button class="btn" id="exportSelectedBtn" style="display: none;">Export Selected</button>
            </div>
            <button class="btn" id="clearLibraryBtn" style="color: var(--error); border-color: var(--error);">Clear All Books</button>
          </div>

          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">About</h3>
            <p style="color: var(--text-secondary); line-height: 1.6;">
              <strong>Book Meta Grabber v2.0</strong><br>
              Extract and enrich metadata from your book collection.<br>
              Supports EPUB, PDF, MP3, M4B, FLAC, and OGG formats.
            </p>
          </div>
        </div>
      </div>
    </main>

    <!-- Tab Bar -->
    <nav class="tab-bar">
      <button class="tab-button active" data-tab="library">
        <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
          <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
        </svg>
        <span class="tab-label">Library</span>
      </button>
      <button class="tab-button" data-tab="search">
        <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.35-4.35"/>
        </svg>
        <span class="tab-label">Search</span>
      </button>
      <button class="tab-button" data-tab="settings">
        <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="3"/>
          <path d="M12 1v6m0 6v6m4.22-13.22 4.24 4.24M1.54 9.54l4.24 4.24M1.54 14.46l4.24-4.24M18.46 14.46l-4.24-4.24"/>
        </svg>
        <span class="tab-label">Settings</span>
      </button>
    </nav>

    <!-- Metadata Editor Modal -->
    <div class="editor-modal" id="editorModal">
      <div class="editor-backdrop" id="editorBackdrop"></div>
      <div class="editor-sheet">
        <!-- Cover Hero Section -->
        <div class="editor-hero" id="editorHero">
          <div class="editor-cover-container">
            <div class="editor-cover" id="editorCover">
              <img id="editorCoverImg" style="display: none;">
              <div class="editor-cover-placeholder" id="editorCoverPlaceholder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                  <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                </svg>
              </div>
            </div>
            <button class="editor-cover-btn" id="editorCoverBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14m-7-7h14"/>
              </svg>
              Change Cover
            </button>
            <input type="file" id="coverInput" accept="image/*" style="display: none;">
          </div>
          <div class="editor-hero-overlay"></div>
        </div>

        <!-- Editor Content -->
        <div class="editor-content">
          <!-- Editor Header -->
          <div class="editor-header">
            <button class="editor-close-btn" id="editorCloseBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
            <h2 class="editor-title">Edit Metadata</h2>
            <div class="editor-actions">
              <button class="btn" id="editorSearchBtn">Search</button>
              <button class="btn btn-primary" id="editorSaveBtn">Save</button>
            </div>
          </div>

          <!-- Search Results (Hidden by default) -->
          <div class="editor-search-results" id="editorSearchResults" style="display: none;">
            <div class="editor-search-header">
              <h3>Search Results</h3>
              <button class="editor-search-close" id="editorSearchClose">×</button>
            </div>
            <div class="editor-search-list" id="editorSearchList">
              <!-- Search results will appear here -->
            </div>
          </div>

          <!-- Metadata Form -->
          <div class="editor-form">
            <div class="editor-form-group">
              <label class="editor-label">Title</label>
              <input type="text" class="editor-input" id="editTitle" placeholder="Book title">
            </div>

            <div class="editor-form-group">
              <label class="editor-label">Author</label>
              <input type="text" class="editor-input" id="editAuthor" placeholder="Author name">
            </div>

            <div class="editor-form-row">
              <div class="editor-form-group">
                <label class="editor-label">Narrator</label>
                <input type="text" class="editor-input" id="editNarrator" placeholder="Narrator (for audiobooks)">
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Series</label>
                <input type="text" class="editor-input" id="editSeries" placeholder="Series name">
              </div>
            </div>

            <div class="editor-form-row">
              <div class="editor-form-group">
                <label class="editor-label">Year</label>
                <input type="text" class="editor-input" id="editYear" placeholder="2024">
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Publisher</label>
                <input type="text" class="editor-input" id="editPublisher" placeholder="Publisher name">
              </div>
            </div>

            <div class="editor-form-row">
              <div class="editor-form-group">
                <label class="editor-label">Genre</label>
                <input type="text" class="editor-input" id="editGenre" placeholder="Fiction, Non-fiction, etc.">
              </div>
              <div class="editor-form-group">
                <label class="editor-label">ISBN</label>
                <input type="text" class="editor-input" id="editIsbn" placeholder="978-0123456789">
              </div>
            </div>

            <div class="editor-form-group">
              <label class="editor-label">Language</label>
              <select class="editor-select" id="editLanguage">
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="ru">Russian</option>
                <option value="ja">Japanese</option>
                <option value="zh">Chinese</option>
                <option value="ko">Korean</option>
                <option value="ar">Arabic</option>
                <option value="hi">Hindi</option>
              </select>
            </div>

            <div class="editor-form-group">
              <label class="editor-label">Description</label>
              <textarea class="editor-textarea" id="editDescription" rows="4" placeholder="Book description or summary"></textarea>
            </div>

            <!-- Audio-specific fields -->
            <div class="editor-audio-fields" id="editorAudioFields" style="display: none;">
              <h4 style="margin: var(--spacing-lg) 0 var(--spacing-md); color: var(--text-secondary);">Audio Information</h4>
              <div class="editor-form-row">
                <div class="editor-form-group">
                  <label class="editor-label">Duration</label>
                  <input type="text" class="editor-input" id="editDuration" placeholder="0:00:00" readonly>
                </div>
                <div class="editor-form-group">
                  <label class="editor-label">Bitrate</label>
                  <input type="text" class="editor-input" id="editBitrate" placeholder="320 kbps" readonly>
                </div>
              </div>
            </div>

            <!-- Reading Progress -->
            <div class="editor-progress-fields">
              <h4 style="margin: var(--spacing-lg) 0 var(--spacing-md); color: var(--text-secondary);">Reading Progress</h4>
              <div class="editor-form-row">
                <div class="editor-form-group">
                  <label class="editor-label">Status</label>
                  <select class="editor-select" id="editStatus">
                    <option value="unread">Unread</option>
                    <option value="reading">Reading</option>
                    <option value="finished">Finished</option>
                    <option value="abandoned">Abandoned</option>
                  </select>
                </div>
                <div class="editor-form-group">
                  <label class="editor-label">Progress (%)</label>
                  <input type="number" class="editor-input" id="editProgress" min="0" max="100" placeholder="0">
                </div>
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Current Page / Chapter</label>
                <input type="text" class="editor-input" id="editCurrentPage" placeholder="Page 1 or Chapter 1">
              </div>
              <div class="editor-form-row">
                <div class="editor-form-group">
                  <label class="editor-label">Started</label>
                  <input type="date" class="editor-input" id="editStartDate">
                </div>
                <div class="editor-form-group">
                  <label class="editor-label">Finished</label>
                  <input type="date" class="editor-input" id="editFinishDate">
                </div>
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Notes</label>
                <textarea class="editor-textarea" id="editNotes" rows="3" placeholder="Personal notes about this book..."></textarea>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== APPLICATION STATE =====
    const state = {
      books: [],
      activeTab: 'library',
      filterFormat: 'all',
      settings: {
        gdriveClientId: '',
        autoFetch: true,
        theme: 'dark'
      },
      currentEditingBook: null,
      selectMode: false,
      selectedBooks: new Set()
    };

    // ===== DOM REFERENCES =====
    const elements = {
      bookGrid: document.getElementById('bookGrid'),
      emptyState: document.getElementById('emptyState'),
      libraryTab: document.getElementById('libraryTab'),
      searchTab: document.getElementById('searchTab'),
      settingsTab: document.getElementById('settingsTab'),
      searchInput: document.getElementById('searchInput'),
      searchResults: document.getElementById('searchResults'),
      gdriveInput: document.getElementById('gdriveInput'),
      exportFormat: document.getElementById('exportFormat'),
      exportSelectedBtn: document.getElementById('exportSelectedBtn'),
      lightThemeBtn: document.getElementById('lightThemeBtn'),
      darkThemeBtn: document.getElementById('darkThemeBtn'),
      tabButtons: document.querySelectorAll('.tab-button'),
      filterChips: document.querySelectorAll('.filter-chip'),
      // Batch operations
      batchActions: document.getElementById('batchActions'),
      selectedCount: document.getElementById('selectedCount'),
      batchEditBtn: document.getElementById('batchEditBtn'),
      batchExportBtn: document.getElementById('batchExportBtn'),
      batchDeleteBtn: document.getElementById('batchDeleteBtn'),
      batchCancelBtn: document.getElementById('batchCancelBtn'),
      selectModeBtn: document.getElementById('selectModeBtn'),
      // Editor elements
      editorModal: document.getElementById('editorModal'),
      editorBackdrop: document.getElementById('editorBackdrop'),
      editorCloseBtn: document.getElementById('editorCloseBtn'),
      editorSaveBtn: document.getElementById('editorSaveBtn'),
      editorSearchBtn: document.getElementById('editorSearchBtn'),
      editorSearchResults: document.getElementById('editorSearchResults'),
      editorSearchClose: document.getElementById('editorSearchClose'),
      editorSearchList: document.getElementById('editorSearchList'),
      editorCover: document.getElementById('editorCover'),
      editorCoverImg: document.getElementById('editorCoverImg'),
      editorCoverPlaceholder: document.getElementById('editorCoverPlaceholder'),
      editorCoverBtn: document.getElementById('editorCoverBtn'),
      coverInput: document.getElementById('coverInput'),
      editorHero: document.getElementById('editorHero'),
      editorAudioFields: document.getElementById('editorAudioFields'),
      // Progress fields
      editStatus: document.getElementById('editStatus'),
      editProgress: document.getElementById('editProgress'),
      editCurrentPage: document.getElementById('editCurrentPage'),
      editStartDate: document.getElementById('editStartDate'),
      editFinishDate: document.getElementById('editFinishDate'),
      editNotes: document.getElementById('editNotes'),
      // Form inputs
      editTitle: document.getElementById('editTitle'),
      editAuthor: document.getElementById('editAuthor'),
      editNarrator: document.getElementById('editNarrator'),
      editSeries: document.getElementById('editSeries'),
      editYear: document.getElementById('editYear'),
      editPublisher: document.getElementById('editPublisher'),
      editGenre: document.getElementById('editGenre'),
      editIsbn: document.getElementById('editIsbn'),
      editLanguage: document.getElementById('editLanguage'),
      editDescription: document.getElementById('editDescription'),
      editDuration: document.getElementById('editDuration'),
      editBitrate: document.getElementById('editBitrate')
    };

    // ===== INITIALIZATION =====
    function init() {
      loadState();
      setupEventListeners();
      renderBooks();
      updateTabDisplay();
    }

    // ===== STATE MANAGEMENT =====
    function saveState() {
      localStorage.setItem('bookMetaGrabber', JSON.stringify(state));
    }

    function loadState() {
      const saved = localStorage.getItem('bookMetaGrabber');
      if (saved) {
        Object.assign(state, JSON.parse(saved));
      }
    }

    // ===== EVENT LISTENERS =====
    function setupEventListeners() {
      // Tab navigation
      elements.tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tab = button.dataset.tab;
          switchTab(tab);
        });
      });

      // Filter chips
      elements.filterChips.forEach(chip => {
        if (chip.id === 'selectModeBtn') {
          chip.addEventListener('click', toggleSelectMode);
        } else {
          chip.addEventListener('click', () => {
            const format = chip.dataset.format;
            setFilter(format);
          });
        }
      });

      // Header buttons
      document.getElementById('searchBtn').addEventListener('click', () => switchTab('search'));
      document.getElementById('addBtn').addEventListener('click', () => addBook());
      document.getElementById('emptyAddBtn').addEventListener('click', () => addBook());

      // Search
      document.getElementById('searchSubmitBtn').addEventListener('click', () => performSearch());
      elements.searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') performSearch();
      });

      // Settings
      document.getElementById('exportBtn').addEventListener('click', () => exportLibrary());
      document.getElementById('exportSelectedBtn').addEventListener('click', () => exportSelected());
      document.getElementById('clearLibraryBtn').addEventListener('click', () => clearLibrary());
      elements.gdriveInput.addEventListener('change', () => {
        state.settings.gdriveClientId = elements.gdriveInput.value;
        saveState();
      });

      // Settings load
      elements.gdriveInput.value = state.settings.gdriveClientId || '';
      elements.exportFormat.value = state.settings.exportFormat || 'json';

      // Theme
      elements.lightThemeBtn.addEventListener('click', () => setTheme('light'));
      elements.darkThemeBtn.addEventListener('click', () => setTheme('dark'));
      updateThemeUI();

      // Batch operations
      elements.batchCancelBtn.addEventListener('click', exitSelectMode);
      elements.batchEditBtn.addEventListener('click', batchEdit);
      elements.batchExportBtn.addEventListener('click', batchExport);
      elements.batchDeleteBtn.addEventListener('click', batchDelete);

      // Editor event listeners
      elements.editorCloseBtn.addEventListener('click', closeEditor);
      elements.editorBackdrop.addEventListener('click', closeEditor);
      elements.editorSaveBtn.addEventListener('click', saveEditor);
      elements.editorSearchBtn.addEventListener('click', searchInEditor);
      elements.editorSearchClose.addEventListener('click', closeEditorSearch);
      elements.editorCoverBtn.addEventListener('click', () => elements.coverInput.click());
      elements.coverInput.addEventListener('change', handleCoverUpload);
    }

    // ===== TAB MANAGEMENT =====
    function switchTab(tabName) {
      state.activeTab = tabName;
      updateTabDisplay();
      saveState();
    }

    function updateTabDisplay() {
      // Update tab buttons
      elements.tabButtons.forEach(button => {
        button.classList.toggle('active', button.dataset.tab === state.activeTab);
      });

      // Update tab screens
      elements.libraryTab.classList.toggle('active', state.activeTab === 'library');
      elements.searchTab.classList.toggle('active', state.activeTab === 'search');
      elements.settingsTab.classList.toggle('active', state.activeTab === 'settings');
    }

    // ===== FILTER MANAGEMENT =====
    function setFilter(format) {
      state.filterFormat = format;
      updateFilterDisplay();
      renderBooks();
      saveState();
    }

    function updateFilterDisplay() {
      elements.filterChips.forEach(chip => {
        chip.classList.toggle('active', chip.dataset.format === state.filterFormat);
      });
    }

    // ===== BOOK MANAGEMENT =====
    function addBook() {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.epub,.pdf,.mp3,.m4b,.m4a,.flac,.ogg';
      
      input.onchange = (e) => {
        const files = Array.from(e.target.files);
        files.forEach(file => {
          const book = createBookFromFile(file);
          state.books.unshift(book);
        });
        
        renderBooks();
        saveState();
        showToast(`Added ${files.length} book${files.length > 1 ? 's' : ''}`);
      };
      
      input.click();
    }

    function createBookFromFile(file) {
      const format = file.name.split('.').pop().toLowerCase();
      const fileName = file.name.replace(/\.[^/.]+$/, '');
      
      // Enhanced filename parsing for better title/author detection
      const { title, author, series, year } = parseFileName(fileName);
      
      return {
        id: Date.now() + Math.random(),
        fileName: file.name,
        format: format,
        title: title,
        author: author,
        narrator: '',
        series: series,
        year: year,
        publisher: '',
        genre: '',
        isbn: '',
        description: '',
        language: 'en',
        coverBase64: null,
        coverMime: null,
        file: file,
        addedDate: new Date().toISOString(),
        // Reading progress
        status: 'unread',
        progress: 0,
        currentPage: '',
        startDate: '',
        finishDate: '',
        notes: ''
      };
    }

    function parseFileName(fileName) {
      // Remove common patterns and clean up the filename
      let cleaned = fileName
        .replace(/[\[\](){}]/g, ' ') // Remove brackets
        .replace(/[._-]/g, ' ') // Replace dots, underscores, hyphens with spaces
        .replace(/\s+/g, ' ') // Multiple spaces to single space
        .trim();

      // Common patterns to detect and extract metadata
      const patterns = [
        // Series patterns: "Series Name #1" or "Series Name Book 1"
        {
          regex: /^(.+?)(?:\s+(?:#|book)\s*(\d+))$/i,
          handler: (match, title, seriesNum) => ({
            title: title.trim(),
            series: `${title.trim()} #${seriesNum}`,
            author: '',
            year: ''
          })
        },
        // Author first: "Author - Title" or "Author - Title (Year)"
        {
          regex: /^(.+?)\s*[-–—]\s*(.+?)(?:\s*\((\d{4})\))?$/,
          handler: (match, author, title, year) => ({
            title: title.trim(),
            author: author.trim(),
            series: '',
            year: year || ''
          })
        },
        // Title first with author in brackets: "Title - Author Name"
        {
          regex: /^(.+?)\s*[-–—]\s*(.+?)$/,
          handler: (match, title, author) => {
            // Check if second part looks like an author (shorter, no numbers)
            if (author.split(' ').length <= 3 && !/\d/.test(author)) {
              return {
                title: title.trim(),
                author: author.trim(),
                series: '',
                year: ''
              };
            }
            return null;
          }
        },
        // Year in parentheses: "Title (Year)" or "Title by Author (Year)"
        {
          regex: /^(.+?)\s*\((\d{4})\)\s*(?:by\s*(.+))?$/i,
          handler: (match, title, year, author) => ({
            title: title.trim(),
            author: author ? author.trim() : '',
            series: '',
            year: year
          })
        },
        // Multiple authors separated by & or and: "Title - Author & Author"
        {
          regex: /^(.+?)\s*[-–—]\s*(.+?(?:\s+(?:and|&)\s*.+?)?)$/,
          handler: (match, title, authors) => ({
            title: title.trim(),
            author: authors.trim(),
            series: '',
            year: ''
          })
        }
      ];

      // Try each pattern
      for (const pattern of patterns) {
        const match = cleaned.match(pattern.regex);
        if (match) {
          const result = pattern.handler(match, ...match.slice(1));
          if (result) return result;
        }
      }

      // Fallback: try to detect if there are multiple parts that could be title/author
      const parts = cleaned.split(/\s+[-–—]\s+/);
      if (parts.length === 2) {
        const [part1, part2] = parts;
        // Heuristic: shorter part is likely the author
        if (part1.length > part2.length && part2.split(' ').length <= 3) {
          return {
            title: part1.trim(),
            author: part2.trim(),
            series: '',
            year: ''
          };
        } else if (part2.length > part1.length && part1.split(' ').length <= 3) {
          return {
            title: part2.trim(),
            author: part1.trim(),
            series: '',
            year: ''
          };
        }
      }

      // Last resort: treat everything as title
      return {
        title: cleaned,
        author: '',
        series: '',
        year: ''
      };
    }

    function clearLibrary() {
      if (confirm('Are you sure you want to clear all books? This cannot be undone.')) {
        state.books = [];
        renderBooks();
        saveState();
        showToast('Library cleared');
      }
    }

    function exportLibrary() {
      const format = elements.exportFormat.value;
      const books = state.books;
      exportBooks(books, format);
    }

    function exportSelected() {
      const format = elements.exportFormat.value;
      const selectedBooks = state.books.filter(book => state.selectedBooks.has(book.id));
      exportBooks(selectedBooks, format);
    }

    function exportBooks(books, format) {
      if (books.length === 0) {
        showToast('No books to export', 'warning');
        return;
      }

      try {
        let content, filename, mimeType;
        
        switch (format) {
          case 'csv':
            content = exportToCSV(books);
            filename = `books-${new Date().toISOString().split('T')[0]}.csv`;
            mimeType = 'text/csv';
            break;
          case 'pdf':
            content = exportToPDF(books);
            filename = `books-${new Date().toISOString().split('T')[0]}.pdf`;
            mimeType = 'application/pdf';
            break;
          default: // json
            content = JSON.stringify(books, null, 2);
            filename = `books-${new Date().toISOString().split('T')[0]}.json`;
            mimeType = 'application/json';
        }

        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        
        showToast(`Exported ${books.length} book${books.length > 1 ? 's' : ''} as ${format.toUpperCase()}`, 'success');
      } catch (error) {
        showToast('Export failed', 'error');
        console.error('Export error:', error);
      }
    }

    function exportToCSV(books) {
      const headers = [
        'Title', 'Author', 'Narrator', 'Series', 'Year', 'Publisher',
        'Genre', 'ISBN', 'Language', 'Format', 'Status', 'Progress (%)',
        'Current Page', 'Start Date', 'Finish Date', 'Added Date', 'Notes'
      ];
      
      const rows = books.map(book => [
        book.title || '',
        book.author || '',
        book.narrator || '',
        book.series || '',
        book.year || '',
        book.publisher || '',
        book.genre || '',
        book.isbn || '',
        book.language || '',
        book.format || '',
        book.status || '',
        book.progress || 0,
        book.currentPage || '',
        book.startDate || '',
        book.finishDate || '',
        book.addedDate || '',
        book.notes || ''
      ]);

      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(cell => `"${cell.toString().replace(/"/g, '""')}"`).join(','))
      ].join('\n');

      return csvContent;
    }

    function exportToPDF(books) {
      // Simple PDF generation using browser capabilities
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        // Load jsPDF dynamically if not available
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        script.onload = () => {
          generatePDFContent(books);
        };
        document.head.appendChild(script);
        showToast('Loading PDF export...', 'info');
        return;
      }
      
      return generatePDFContent(books);
    }

    function generatePDFContent(books) {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Add title
      doc.setFontSize(20);
      doc.text('Book Library Export', 20, 20);
      
      // Add date
      doc.setFontSize(10);
      doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 30);
      
      // Add books
      let yPosition = 50;
      const lineHeight = 10;
      const pageHeight = doc.internal.pageSize.height;
      
      books.forEach((book, index) => {
        // Check if we need a new page
        if (yPosition > pageHeight - 40) {
          doc.addPage();
          yPosition = 20;
        }
        
        // Book title
        doc.setFontSize(12);
        doc.text(`${index + 1}. ${book.title || 'Untitled'}`, 20, yPosition);
        yPosition += lineHeight;
        
        // Book details
        doc.setFontSize(10);
        const details = [
          `Author: ${book.author || 'Unknown'}`,
          `Format: ${book.format?.toUpperCase() || 'Unknown'}`,
          `Status: ${getStatusLabel(book.status)}`
        ];
        
        details.forEach(detail => {
          doc.text(detail, 25, yPosition);
          yPosition += lineHeight * 0.8;
        });
        
        yPosition += lineHeight * 0.5;
      });
      
      return doc.output('blob');
    }

    // ===== THEME FUNCTIONS =====
    function setTheme(theme) {
      state.settings.theme = theme;
      document.documentElement.setAttribute('data-theme', theme);
      updateThemeUI();
      saveState();
      showToast(`Switched to ${theme} theme`, 'success');
    }

    function updateThemeUI() {
      const theme = state.settings.theme || 'dark';
      document.documentElement.setAttribute('data-theme', theme);
      
      // Update button states
      elements.lightThemeBtn.classList.toggle('active', theme === 'light');
      elements.darkThemeBtn.classList.toggle('active', theme === 'dark');
    }

    // ===== RENDERING =====
    function renderBooks() {
      const filteredBooks = state.filterFormat === 'all' 
        ? state.books 
        : state.books.filter(book => book.format === state.filterFormat);

      elements.bookGrid.innerHTML = '';
      elements.emptyState.style.display = filteredBooks.length === 0 ? 'block' : 'none';

      filteredBooks.forEach((book, index) => {
        const card = createBookCard(book, index);
        elements.bookGrid.appendChild(card);
      });
    }

    function createBookCard(book, index) {
      const card = document.createElement('div');
      card.className = 'book-card';
      card.dataset.bookId = book.id;
      card.style.animationDelay = `${index * 50}ms`;
      
      const coverHtml = book.coverBase64 
        ? `<img src="data:${book.coverMime || 'image/jpeg'};base64,${book.coverBase64}" alt="${book.title}">`
        : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.3">
             <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
             <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
           </svg>`;

      card.innerHTML = `
        <div class="book-cover">
          ${coverHtml}
          ${book.progress > 0 ? `<div class="book-progress-indicator">${book.progress}%</div>` : ''}
        </div>
        <div class="book-info">
          <div class="book-title">${escapeHtml(book.title || book.fileName)}</div>
          <div class="book-author">${escapeHtml(book.author || 'Unknown Author')}</div>
          ${book.status !== 'unread' ? `<div class="book-status">${getStatusLabel(book.status)}</div>` : ''}
        </div>
        <div class="book-format">${book.format.toUpperCase()}</div>
      `;

      // Add click handler based on mode
      card.addEventListener('click', (e) => {
        if (state.selectMode) {
          toggleBookSelection(book.id);
        } else {
          openBook(book);
        }
      });

      // Update selection state
      if (state.selectMode) {
        card.classList.add('select-mode');
        if (state.selectedBooks.has(book.id)) {
          card.classList.add('selected');
        }
      }

      return card;
    }

    function getStatusLabel(status) {
      const labels = {
        'unread': '📚 Unread',
        'reading': '📖 Reading',
        'finished': '✅ Finished',
        'abandoned': '🚫 Abandoned'
      };
      return labels[status] || status;
    }

    // ===== SEARCH =====
    async function performSearch() {
      const query = elements.searchInput.value.trim();
      if (!query) return;

      elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">Searching...</p>';
      
      try {
        // Mock search results for now
        const results = await mockSearch(query);
        renderSearchResults(results);
      } catch (error) {
        elements.searchResults.innerHTML = '<p style="color: var(--error);">Search failed. Please try again.</p>';
      }
    }

    async function mockSearch(query) {
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Mock results
      return [
        {
          title: `${query} - Result 1`,
          author: 'Mock Author',
          year: '2023',
          isbn: '9780000000001'
        },
        {
          title: `${query} - Result 2`, 
          author: 'Another Author',
          year: '2022',
          isbn: '9780000000002'
        }
      ];
    }

    function renderSearchResults(results) {
      if (results.length === 0) {
        elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">No results found.</p>';
        return;
      }

      const html = results.map(result => `
        <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--spacing-md); margin-bottom: var(--spacing-sm);">
          <h4 style="margin-bottom: var(--spacing-xs);">${escapeHtml(result.title)}</h4>
          <p style="color: var(--text-secondary); font-size: 0.875rem;">
            ${escapeHtml(result.author)} • ${result.year}
          </p>
          <button class="btn btn-primary" style="margin-top: var(--spacing-sm);">Use This</button>
        </div>
      `).join('');

      elements.searchResults.innerHTML = html;
    }

    // ===== UTILITIES =====
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--surface);
        color: var(--text-primary);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-md);
        border: 1px solid var(--border);
        box-shadow: var(--shadow-lg);
        z-index: 1000;
        animation: slideUp 0.3s ease-out;
      `;
      toast.textContent = message;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideDown 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    function openBook(book) {
      state.currentEditingBook = book;
      populateEditor(book);
      elements.editorModal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    // ===== EDITOR FUNCTIONS =====
    function populateEditor(book) {
      // Basic metadata
      elements.editTitle.value = book.title || '';
      elements.editAuthor.value = book.author || '';
      elements.editNarrator.value = book.narrator || '';
      elements.editSeries.value = book.series || '';
      elements.editYear.value = book.year || '';
      elements.editPublisher.value = book.publisher || '';
      elements.editGenre.value = book.genre || '';
      elements.editIsbn.value = book.isbn || '';
      elements.editLanguage.value = book.language || 'en';
      elements.editDescription.value = book.description || '';

      // Reading progress
      elements.editStatus.value = book.status || 'unread';
      elements.editProgress.value = book.progress || 0;
      elements.editCurrentPage.value = book.currentPage || '';
      elements.editStartDate.value = book.startDate || '';
      elements.editFinishDate.value = book.finishDate || '';
      elements.editNotes.value = book.notes || '';

      // Cover image
      if (book.coverBase64) {
        elements.editorCoverImg.src = `data:${book.coverMime || 'image/jpeg'};base64,${book.coverBase64}`;
        elements.editorCoverImg.style.display = 'block';
        elements.editorCoverPlaceholder.style.display = 'none';
        
        // Set hero background
        elements.editorHero.style.background = `linear-gradient(135deg, 
          rgba(99, 102, 241, 0.1) 0%, 
          rgba(139, 92, 246, 0.1) 100%), 
          url('data:${book.coverMime || 'image/jpeg'};base64,${book.coverBase64}') center/cover`;
      } else {
        elements.editorCoverImg.style.display = 'none';
        elements.editorCoverPlaceholder.style.display = 'flex';
        elements.editorHero.style.background = 'var(--surface)';
      }

      // Audio-specific fields
      const isAudio = ['mp3', 'm4b', 'm4a', 'flac', 'ogg', 'opus'].includes(book.format);
      if (isAudio) {
        elements.editorAudioFields.style.display = 'block';
        elements.editDuration.value = formatDuration(book.duration);
        elements.editBitrate.value = book.bitrate ? `${book.bitrate} kbps` : '';
      } else {
        elements.editorAudioFields.style.display = 'none';
      }
    }

    function closeEditor() {
      elements.editorModal.classList.remove('active');
      document.body.style.overflow = '';
      state.currentEditingBook = null;
      closeEditorSearch();
    }

    function saveEditor() {
      if (!state.currentEditingBook) return;

      // Update book object
      const book = state.currentEditingBook;
      book.title = elements.editTitle.value;
      book.author = elements.editAuthor.value;
      book.narrator = elements.editNarrator.value;
      book.series = elements.editSeries.value;
      book.year = elements.editYear.value;
      book.publisher = elements.editPublisher.value;
      book.genre = elements.editGenre.value;
      book.isbn = elements.editIsbn.value;
      book.language = elements.editLanguage.value;
      book.description = elements.editDescription.value;

      // Reading progress
      book.status = elements.editStatus.value;
      book.progress = parseInt(elements.editProgress.value) || 0;
      book.currentPage = elements.editCurrentPage.value;
      book.startDate = elements.editStartDate.value;
      book.finishDate = elements.editFinishDate.value;
      book.notes = elements.editNotes.value;

      // Auto-update status based on progress
      if (book.progress === 0 && book.status !== 'unread') {
        book.status = 'unread';
      } else if (book.progress > 0 && book.progress < 100 && book.status !== 'reading' && book.status !== 'abandoned') {
        book.status = 'reading';
      } else if (book.progress === 100 && book.status !== 'finished') {
        book.status = 'finished';
        if (!book.finishDate) {
          book.finishDate = new Date().toISOString().split('T')[0];
        }
      }

      // Update the book in the array
      const index = state.books.findIndex(b => b.id === book.id);
      if (index !== -1) {
        state.books[index] = book;
      }

      renderBooks();
      saveState();
      closeEditor();
      showToast('Metadata saved successfully', 'success');
    }

    async function searchInEditor() {
      if (!state.currentEditingBook) return;

      const query = `${elements.editTitle.value} ${elements.editAuthor.value}`.trim();
      if (!query) {
        showToast('Enter a title or author to search', 'warning');
        return;
      }

      elements.editorSearchResults.style.display = 'block';
      elements.editorSearchList.innerHTML = '<p style="color: var(--text-secondary); padding: var(--spacing-md);">Searching...</p>';

      try {
        const results = await fetchExternalMetadata(query, '');
        renderEditorSearchResults(results);
      } catch (error) {
        elements.editorSearchList.innerHTML = '<p style="color: var(--error); padding: var(--spacing-md);">Search failed. Please try again.</p>';
      }
    }

    function renderEditorSearchResults(results) {
      if (results.length === 0) {
        elements.editorSearchList.innerHTML = '<p style="color: var(--text-secondary); padding: var(--spacing-md);">No results found.</p>';
        return;
      }

      const html = results.map(result => `
        <div class="editor-search-item" onclick="applyEditorSearchResult(${JSON.stringify(result).replace(/"/g, '&quot;')})">
          <div class="editor-search-item-cover">
            ${result.coverUrl ? `<img src="${result.coverUrl}" alt="${escapeHtml(result.title)}">` : ''}
          </div>
          <div class="editor-search-item-info">
            <div class="editor-search-item-title">${escapeHtml(result.title)}</div>
            <div class="editor-search-item-author">${escapeHtml(result.author || 'Unknown Author')}</div>
          </div>
        </div>
      `).join('');

      elements.editorSearchList.innerHTML = html;
    }

    function closeEditorSearch() {
      elements.editorSearchResults.style.display = 'none';
      elements.editorSearchList.innerHTML = '';
    }

    async function handleCoverUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      if (!file.type.startsWith('image/')) {
        showToast('Please select an image file', 'error');
        return;
      }

      try {
        const base64 = await fileToBase64(file);
        const book = state.currentEditingBook;
        
        book.coverBase64 = base64.split(',')[1];
        book.coverMime = file.type;

        // Update editor display
        elements.editorCoverImg.src = base64;
        elements.editorCoverImg.style.display = 'block';
        elements.editorCoverPlaceholder.style.display = 'none';
        
        // Update hero background
        elements.editorHero.style.background = `linear-gradient(135deg, 
          rgba(99, 102, 241, 0.1) 0%, 
          rgba(139, 92, 246, 0.1) 100%), 
          url('${base64}') center/cover`;

        showToast('Cover updated', 'success');
      } catch (error) {
        showToast('Failed to upload cover', 'error');
      }
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function formatDuration(seconds) {
      if (!seconds) return '';
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Apply search result to editor form
    window.applyEditorSearchResult = function(result) {
      elements.editTitle.value = result.title || elements.editTitle.value;
      elements.editAuthor.value = result.author || elements.editAuthor.value;
      elements.editPublisher.value = result.publisher || elements.editPublisher.value;
      elements.editYear.value = result.year || elements.editYear.value;
      elements.editGenre.value = result.genre || elements.editGenre.value;
      elements.editIsbn.value = result.isbn || elements.editIsbn.value;
      elements.editDescription.value = result.description || elements.editDescription.value;

      // Fetch cover if available
      if (result.coverUrl && !state.currentEditingBook.coverBase64) {
        fetch(result.coverUrl)
          .then(response => response.blob())
          .then(blob => blobToBase64(blob))
          .then(base64 => {
            const book = state.currentEditingBook;
            book.coverBase64 = base64.split(',')[1];
            book.coverMime = blob.type;

            elements.editorCoverImg.src = base64;
            elements.editorCoverImg.style.display = 'block';
            elements.editorCoverPlaceholder.style.display = 'none';
            
            elements.editorHero.style.background = `linear-gradient(135deg, 
              rgba(99, 102, 241, 0.1) 0%, 
              rgba(139, 92, 246, 0.1) 100%), 
              url('${base64}') center/cover`;
          })
          .catch(() => {
            // Silently fail if cover fetch fails
          });
      }

      closeEditorSearch();
      showToast('Metadata applied from search result', 'success');
    };

    // ===== BATCH OPERATIONS =====
    function toggleSelectMode() {
      state.selectMode = !state.selectMode;
      
      if (state.selectMode) {
        elements.selectModeBtn.classList.add('active');
        elements.selectModeBtn.textContent = 'Cancel';
        elements.batchActions.style.display = 'flex';
        elements.exportSelectedBtn.style.display = 'block';
        state.selectedBooks.clear();
      } else {
        exitSelectMode();
      }
      
      renderBooks();
    }

    function exitSelectMode() {
      state.selectMode = false;
      state.selectedBooks.clear();
      elements.selectModeBtn.classList.remove('active');
      elements.selectModeBtn.textContent = 'Select';
      elements.batchActions.style.display = 'none';
      elements.exportSelectedBtn.style.display = 'none';
      renderBooks();
    }

    function toggleBookSelection(bookId) {
      if (state.selectedBooks.has(bookId)) {
        state.selectedBooks.delete(bookId);
      } else {
        state.selectedBooks.add(bookId);
      }
      
      updateBatchUI();
    }

    function updateBatchUI() {
      const count = state.selectedBooks.size;
      elements.selectedCount.textContent = count;
      
      // Update card selection states
      document.querySelectorAll('.book-card').forEach(card => {
        const bookId = card.dataset.bookId;
        if (state.selectedBooks.has(bookId)) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
    }

    function batchEdit() {
      if (state.selectedBooks.size === 0) {
        showToast('No books selected', 'warning');
        return;
      }
      
      if (state.selectedBooks.size === 1) {
        // Single book - open regular editor
        const bookId = Array.from(state.selectedBooks)[0];
        const book = state.books.find(b => b.id === bookId);
        if (book) openBook(book);
      } else {
        // Multiple books - show batch edit dialog
        showToast('Batch editing coming soon!', 'info');
      }
    }

    function batchExport() {
      if (state.selectedBooks.size === 0) {
        showToast('No books selected', 'warning');
        return;
      }
      
      const selectedBooks = state.books.filter(book => state.selectedBooks.has(book.id));
      const data = JSON.stringify(selectedBooks, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `selected-books-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast(`Exported ${state.selectedBooks.size} book${state.selectedBooks.size > 1 ? 's' : ''}`, 'success');
    }

    function batchDelete() {
      if (state.selectedBooks.size === 0) {
        showToast('No books selected', 'warning');
        return;
      }
      
      const count = state.selectedBooks.size;
      if (!confirm(`Are you sure you want to delete ${count} book${count > 1 ? 's' : ''}? This cannot be undone.`)) {
        return;
      }
      
      // Remove selected books
      state.books = state.books.filter(book => !state.selectedBooks.has(book.id));
      
      exitSelectMode();
      renderBooks();
      saveState();
      showToast(`Deleted ${count} book${count > 1 ? 's' : ''}`, 'success');
    }

    // ===== ANIMATIONS =====
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideUp {
        from { transform: translate(-50%, 100px); opacity: 0; }
        to { transform: translate(-50%, 0); opacity: 1; }
      }
      @keyframes slideDown {
        from { transform: translate(-50%, 0); opacity: 1; }
        to { transform: translate(-50%, 100px); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // ===== METADATA EXTRACTION =====
    async function extractMetadata(file) {
      const format = file.name.split('.').pop().toLowerCase();
      const book = createBookFromFile(file);
      
      try {
        switch (format) {
          case 'epub':
            return await extractEpubMetadata(file, book);
          case 'pdf':
            return await extractPdfMetadata(file, book);
          case 'mp3':
          case 'm4b':
          case 'm4a':
          case 'flac':
          case 'ogg':
          case 'opus':
            return await extractAudioMetadata(file, book);
          default:
            return book;
        }
      } catch (error) {
        console.warn('Metadata extraction failed:', error);
        return book;
      }
    }

    async function extractEpubMetadata(file, book) {
      const arrayBuffer = await file.arrayBuffer();
      const zip = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
      
      try {
        const epub = await zip.default.loadAsync(arrayBuffer);
        
        // Parse container.xml
        const container = await epub.file('META-INF/container.xml').async('string');
        const parser = new DOMParser();
        const containerDoc = parser.parseFromString(container, 'text/xml');
        const opfPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
        
        if (!opfPath) return book;
        
        // Parse OPF file
        const opfContent = await epub.file(opfPath).async('string');
        const opfDoc = parser.parseFromString(opfContent, 'text/xml');
        
        // Enhanced metadata extraction
        const title = extractTextContent(opfDoc, 'title') || book.title;
        const author = extractTextContent(opfDoc, 'creator') || book.author;
        const publisher = extractTextContent(opfDoc, 'publisher') || '';
        const description = cleanHtml(extractTextContent(opfDoc, 'description') || '');
        const isbn = extractISBN(opfDoc) || '';
        const language = extractTextContent(opfDoc, 'language') || 'en';
        const publisherDate = extractTextContent(opfDoc, 'date') || '';
        const subjects = extractMultipleTextContent(opfDoc, 'subject') || [];
        const genre = subjects.slice(0, 3).join(', ') || book.genre;
        
        // Extract series information from dc:subject or meta tags
        const series = extractSeries(opfDoc) || book.series;
        
        // Extract cover with better fallback
        const coverData = await extractEpubCover(epub, opfDoc, opfPath);
        
        return {
          ...book,
          title: cleanTitle(title),
          author: cleanAuthor(author),
          publisher: publisher,
          description: description,
          isbn: isbn,
          language: language,
          year: extractYear(publisherDate) || book.year,
          genre: genre,
          series: series,
          ...coverData
        };
      } catch (error) {
        console.warn('EPUB parsing failed:', error);
        return book;
      }
    }

    function extractTextContent(doc, tagName) {
      const element = doc.querySelector(tagName);
      return element ? element.textContent.trim() : '';
    }

    function extractMultipleTextContent(doc, tagName) {
      const elements = doc.querySelectorAll(tagName);
      return Array.from(elements).map(el => el.textContent.trim()).filter(Boolean);
    }

    function extractISBN(doc) {
      // Try different ISBN identifiers
      const isbn13 = doc.querySelector('identifier[scheme="ISBN13"], identifier[opf:scheme="ISBN13"]');
      if (isbn13) return isbn13.textContent.trim();
      
      const isbn10 = doc.querySelector('identifier[scheme="ISBN10"], identifier[opf:scheme="ISBN10"]');
      if (isbn10) return isbn10.textContent.trim();
      
      const isbn = doc.querySelector('identifier[type="isbn"], identifier[id*="isbn"]');
      return isbn ? isbn.textContent.trim() : '';
    }

    function extractSeries(doc) {
      // Try to extract series from subject or meta tags
      const seriesSubject = Array.from(doc.querySelectorAll('subject'))
        .find(subject => subject.textContent.toLowerCase().includes('series'));
      
      if (seriesSubject) {
        return seriesSubject.textContent.trim();
      }
      
      // Check meta tags for series information
      const metaSeries = Array.from(doc.querySelectorAll('meta'))
        .find(meta => {
          const name = meta.getAttribute('name') || meta.getAttribute('property');
          return name && (name.toLowerCase().includes('series') || name.toLowerCase().includes('calibre:series'));
        });
      
      if (metaSeries) {
        return metaSeries.getAttribute('content') || metaSeries.textContent.trim();
      }
      
      return '';
    }

    async function extractEpubCover(epub, opfDoc, opfPath) {
      // Try multiple methods to find cover
      const coverItem = opfDoc.querySelector('item[properties="cover-image"]');
      if (coverItem) {
        const coverHref = coverItem.getAttribute('href');
        const coverPath = opfPath.replace(/[^/]*$/, '') + coverHref;
        const coverFile = epub.file(coverPath);
        if (coverFile) {
          const coverData = await coverFile.async('base64');
          return {
            coverBase64: coverData,
            coverMime: coverFile.name.split('.').pop() === 'png' ? 'image/png' : 'image/jpeg'
          };
        }
      }
      
      // Fallback: look for common cover image names
      const coverNames = ['cover.jpg', 'cover.png', 'Cover.jpg', 'Cover.png'];
      for (const coverName of coverNames) {
        const coverFile = epub.file(coverName);
        if (coverFile) {
          const coverData = await coverFile.async('base64');
          return {
            coverBase64: coverData,
            coverMime: coverFile.name.split('.').pop() === 'png' ? 'image/png' : 'image/jpeg'
          };
        }
      }
      
      return { coverBase64: null, coverMime: null };
    }

    function cleanTitle(title) {
      return title
        .replace(/\s+/g, ' ')
        .replace(/[\[\](){}]/g, '')
        .trim();
    }

    function cleanAuthor(author) {
      return author
        .replace(/\s+/g, ' ')
        .replace(/[\[\](){}]/g, '')
        .replace(/by\s+/gi, '')
        .trim();
    }

    function cleanHtml(html) {
      return html
        .replace(/<[^>]+>/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function extractYear(dateString) {
      if (!dateString) return '';
      const yearMatch = dateString.match(/(\d{4})/);
      return yearMatch ? yearMatch[1] : '';
    }

    async function extractPdfMetadata(file, book) {
      try {
        const pdfjsLib = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js');
        const pdfjsWorker = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js');
        
        pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker.default;
        
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        // Get PDF metadata
        const metadata = await pdf.getMetadata();
        
        // Extract basic PDF info
        const pdfInfo = pdf.info;
        const title = pdfInfo.title || book.title;
        const author = pdfInfo.author || book.author;
        const subject = pdfInfo.subject || '';
        const creator = pdfInfo.creator || '';
        const producer = pdfInfo.producer || '';
        const creationDate = pdfInfo.creationDate || '';
        const modificationDate = pdfInfo.modificationDate || '';
        
        // Enhanced text extraction from first few pages
        let fullText = '';
        const pagesToExtract = Math.min(3, pdf.numPages);
        
        for (let i = 1; i <= pagesToExtract; i++) {
          try {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');
            fullText += pageText + '\n';
          } catch (pageError) {
            console.warn(`Failed to extract text from page ${i}:`, pageError);
          }
        }
        
        // Try to extract title from text if not found in metadata
        let extractedTitle = title;
        if (!extractedTitle && fullText) {
          const lines = fullText.split('\n').filter(line => line.trim());
          // Look for likely title lines (longer, not all caps, not just numbers)
          for (const line of lines.slice(0, 10)) {
            const cleanLine = line.trim();
            if (cleanLine.length > 10 && 
                cleanLine.length < 100 && 
                !cleanLine.match(/^\d+$/) && 
                !cleanLine.match(/^[A-Z\s]+$/) &&
                !cleanLine.toLowerCase().includes('chapter') &&
                !cleanLine.toLowerCase().includes('page')) {
              extractedTitle = cleanLine;
              break;
            }
          }
        }
        
        // Try to extract author from text if not found in metadata
        let extractedAuthor = author;
        if (!extractedAuthor && fullText) {
          // Look for "by Author" patterns
          const byAuthorMatch = fullText.match(/(?:by|author)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2})/i);
          if (byAuthorMatch) {
            extractedAuthor = byAuthorMatch[1];
          }
        }
        
        // Extract year from dates or text
        let year = '';
        if (creationDate) {
          year = extractYear(creationDate.toString());
        } else if (fullText) {
          const yearMatch = fullText.match(/\b(19|20)\d{2}\b/);
          if (yearMatch) {
            year = yearMatch[0];
          }
        }
        
        // Clean description from first page text
        let description = '';
        if (fullText) {
          const lines = fullText.split('\n').filter(line => line.trim());
          // Take first few meaningful lines as description
          const meaningfulLines = lines.slice(0, 5).filter(line => 
            line.length > 20 && 
            !line.match(/^\d+$/) &&
            !line.toLowerCase().includes('chapter') &&
            !line.toLowerCase().includes('page')
          );
          description = meaningfulLines.join(' ').substring(0, 500);
        }
        
        return {
          ...book,
          title: cleanTitle(extractedTitle),
          author: cleanAuthor(extractedAuthor),
          publisher: producer,
          description: description,
          year: year || book.year,
          genre: subject || book.genre
        };
      } catch (error) {
        console.warn('PDF parsing failed:', error);
        return book;
      }
    }

    async function extractAudioMetadata(file, book) {
      try {
        const musicMetadata = await import('https://cdn.jsdelivr.net/npm/music-metadata-browser@2.2.10/dist/metadata.min.js');
        
        const arrayBuffer = await file.arrayBuffer();
        const metadata = await musicMetadata.parseBuffer(arrayBuffer, {
          mimeType: `audio/${file.name.split('.').pop()}`,
          size: file.size
        });
        
        // Extract cover art with better fallback
        let coverBase64 = null;
        let coverMime = null;
        const cover = metadata.common.picture;
        if (cover && cover.length > 0) {
          // Use the first available cover
          const coverData = cover[0];
          coverBase64 = btoa(String.fromCharCode(...new Uint8Array(coverData.data)));
          coverMime = coverData.format;
        }
        
        // Enhanced metadata extraction with fallbacks
        const title = metadata.common.title || book.title;
        const author = metadata.common.artist || book.author;
        const album = metadata.common.album || '';
        const genre = metadata.common.genre?.[0] || book.genre;
        const year = metadata.common.year?.toString() || book.year;
        const track = metadata.common.track?.no?.toString() || '';
        const disk = metadata.common.disk?.no?.toString() || '';
        
        // For audiobooks, try to extract narrator from comments or other fields
        let narrator = '';
        if (metadata.common.comment) {
          const comments = Array.isArray(metadata.common.comment) 
            ? metadata.common.comment 
            : [metadata.common.comment];
          
          // Look for narrator information in comments
          const narratorComment = comments.find(comment => 
            comment.toLowerCase().includes('narrator') ||
            comment.toLowerCase().includes('read by') ||
            comment.toLowerCase().includes('voiced by')
          );
          
          if (narratorComment) {
            const narratorMatch = narratorComment.match(/(?:narrator|read by|voiced by)[:\s]+(.+?)(?:[,;]|$)/i);
            if (narratorMatch) {
              narrator = narratorMatch[1].trim();
            }
          }
        }
        
        // Try to detect if this is an audiobook vs music
        const isAudiobook = detectAudiobook(metadata, file.name);
        
        // Extract technical audio information
        const format = metadata.format;
        const duration = format.duration ? Math.round(format.duration) : null;
        const bitrate = format.bitrate || null;
        const sampleRate = format.sampleRate || null;
        const channels = format.numberOfChannels || null;
        const codec = format.codec || '';
        
        // Extract additional metadata from format-specific tags
        const publisher = metadata.common.label || metadata.common.organization || '';
        const description = metadata.common.description || metadata.common.comment?.[0] || '';
        
        // Try to extract series from album or title
        let series = '';
        if (isAudiobook && album) {
          // Check if album name looks like a series
          const seriesMatch = album.match(/(.+?)(?:\s+(?:#|book)\s*(\d+))?$/i);
          if (seriesMatch) {
            series = seriesMatch[1].trim();
            if (seriesMatch[2]) {
              series += ` #${seriesMatch[2]}`;
            }
          }
        }
        
        return {
          ...book,
          title: cleanTitle(title),
          author: cleanAuthor(author),
          narrator: narrator || (isAudiobook ? author : ''), // Default to author for audiobooks
          series: series,
          year: year,
          publisher: publisher,
          genre: isAudiobook ? 'Audiobook' : genre,
          description: description,
          duration: duration,
          bitrate: bitrate,
          sampleRate: sampleRate,
          channels: channels,
          codec: codec,
          track: track,
          disk: disk,
          album: album,
          coverBase64: coverBase64,
          coverMime: coverMime
        };
      } catch (error) {
        console.warn('Audio metadata extraction failed:', error);
        return book;
      }
    }

    function detectAudiobook(metadata, fileName) {
      // Heuristics to detect if this is an audiobook
      const indicators = [
        // File name indicators
        fileName.toLowerCase().includes('audiobook'),
        fileName.toLowerCase().includes('unabridged'),
        fileName.toLowerCase().includes('abridged'),
        
        // Metadata indicators
        metadata.common.genre?.some(g => g.toLowerCase().includes('audiobook')),
        metadata.common.genre?.some(g => g.toLowerCase().includes('book')),
        metadata.common.album?.toLowerCase().includes('audiobook'),
        
        // Long duration (typical for audiobooks)
        metadata.format.duration && metadata.format.duration > 600, // 10+ minutes
        
        // Single track (common for audiobooks)
        metadata.common.track?.no === 1 && !metadata.common.disk?.no
      ];
      
      return indicators.some(Boolean);
    }

    // ===== EXTERNAL API INTEGRATION =====
    async function fetchExternalMetadata(title, author) {
      const query = `${title} ${author}`.trim();
      const results = [];
      
      try {
        // Import and use real API functions
        const { fetchGoogleBooks, fetchOpenLibrary, fetchItunes, fetchMusicBrainz } = await import('./src/apis/index.js');
        
        const [googleBooks, openLibrary, itunes, musicBrainz] = await Promise.allSettled([
          fetchGoogleBooks(query),
          fetchOpenLibrary(query),
          fetchItunes(query),
          fetchMusicBrainz(query)
        ]);
        
        if (googleBooks.status === 'fulfilled') results.push(...googleBooks.value);
        if (openLibrary.status === 'fulfilled') results.push(...openLibrary.value);
        if (itunes.status === 'fulfilled') results.push(...itunes.value);
        if (musicBrainz.status === 'fulfilled') results.push(...musicBrainz.value);
        
      } catch (error) {
        console.warn('External API fetch failed:', error);
        // Fallback to mock data if APIs fail
        return await mockSearch(query);
      }
      
      return results;
    }

    // ===== ENHANCED BOOK MANAGEMENT =====
    async function addBook() {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.epub,.pdf,.mp3,.m4b,.m4a,.flac,.ogg,.opus';
      
      input.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (!files.length) return;
        
        showToast('Processing files...', 'info');
        
        for (const file of files) {
          try {
            // Extract metadata from file
            const book = await extractMetadata(file);
            
            // Try to fetch external metadata if auto-fetch is enabled
            if (state.settings.autoFetch && book.title) {
              try {
                const externalResults = await fetchExternalMetadata(book.title, book.author);
                if (externalResults.length > 0) {
                  const bestMatch = externalResults[0]; // Use first result for now
                  Object.assign(book, {
                    title: bestMatch.title || book.title,
                    author: bestMatch.author || book.author,
                    publisher: bestMatch.publisher || book.publisher,
                    year: bestMatch.year || book.year,
                    genre: bestMatch.genre || book.genre,
                    isbn: bestMatch.isbn || book.isbn,
                    description: bestMatch.description || book.description
                  });
                  
                  // Fetch cover if available
                  if (bestMatch.coverUrl && !book.coverBase64) {
                    try {
                      const coverResponse = await fetch(bestMatch.coverUrl);
                      const coverBlob = await coverResponse.blob();
                      const coverBase64 = await blobToBase64(coverBlob);
                      book.coverBase64 = coverBase64.split(',')[1];
                      book.coverMime = coverBlob.type;
                    } catch (coverError) {
                      console.warn('Cover fetch failed:', coverError);
                    }
                  }
                }
              } catch (apiError) {
                console.warn('External metadata fetch failed:', apiError);
              }
            }
            
            state.books.unshift(book);
          } catch (fileError) {
            console.error('File processing failed:', fileError);
            showToast(`Failed to process ${file.name}`, 'error');
          }
        }
        
        renderBooks();
        saveState();
        showToast(`Added ${files.length} book${files.length > 1 ? 's' : ''}`, 'success');
      };
      
      input.click();
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // ===== ENHANCED SEARCH =====
    async function performSearch() {
      const query = elements.searchInput.value.trim();
      if (!query) return;

      elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">Searching...</p>';
      
      try {
        const results = await fetchExternalMetadata(query, '');
        renderSearchResults(results);
      } catch (error) {
        elements.searchResults.innerHTML = '<p style="color: var(--error);">Search failed. Please try again.</p>';
      }
    }

    function renderSearchResults(results) {
      if (results.length === 0) {
        elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">No results found.</p>';
        return;
      }

      const html = results.map(result => `
        <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--spacing-md); margin-bottom: var(--spacing-sm);">
          <h4 style="margin-bottom: var(--spacing-xs);">${escapeHtml(result.title)}</h4>
          <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-xs);">
            ${escapeHtml(result.author || 'Unknown Author')} • ${result.year || 'Unknown Year'}
          </p>
          <p style="color: var(--text-muted); font-size: 0.75rem; margin-bottom: var(--spacing-sm);">
            Source: ${escapeHtml(result.source)}
          </p>
          <button class="btn btn-primary" style="margin-top: var(--spacing-sm);" onclick="applySearchResult(${JSON.stringify(result).replace(/"/g, '&quot;')})">
            Use This Metadata
          </button>
        </div>
      `).join('');

      elements.searchResults.innerHTML = html;
    }

    // Apply search result to current book (placeholder)
    window.applySearchResult = function(result) {
      showToast('Metadata selected! Add a book first to apply this metadata.', 'info');
    };

    // ===== ADVANCED FEATURES =====
    
    // Book Editor/Viewer
    function openBook(book) {
      showBookEditor(book);
    }

    function showBookEditor(book) {
      const modal = createBookEditorModal(book);
      document.body.appendChild(modal);
      
      // Animate in
      requestAnimationFrame(() => {
        modal.classList.add('show');
      });
    }

    function createBookEditorModal(book) {
      const modal = document.createElement('div');
      modal.className = 'book-editor-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeBookEditor(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Edit Book</h2>
            <button class="btn btn-icon" onclick="closeBookEditor(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="book-cover-section">
              <div class="cover-preview">
                ${book.coverBase64 ? 
                  `<img src="data:${book.coverMime};base64,${book.coverBase64}" alt="Cover">` :
                  `<div class="cover-placeholder">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                      <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                    </svg>
                  </div>`
                }
              </div>
              <button class="btn" onclick="changeBookCover(${book.id})">Change Cover</button>
            </div>
            <div class="book-form">
              <div class="form-group">
                <label>Title</label>
                <input type="text" id="edit-title" value="${escapeHtml(book.title || '')}">
              </div>
              <div class="form-group">
                <label>Author</label>
                <input type="text" id="edit-author" value="${escapeHtml(book.author || '')}">
              </div>
              <div class="form-group">
                <label>Narrator (Audiobooks)</label>
                <input type="text" id="edit-narrator" value="${escapeHtml(book.narrator || '')}">
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Series</label>
                  <input type="text" id="edit-series" value="${escapeHtml(book.series || '')}">
                </div>
                <div class="form-group">
                  <label>Year</label>
                  <input type="number" id="edit-year" value="${escapeHtml(book.year || '')}">
                </div>
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Publisher</label>
                  <input type="text" id="edit-publisher" value="${escapeHtml(book.publisher || '')}">
                </div>
                <div class="form-group">
                  <label>Genre</label>
                  <input type="text" id="edit-genre" value="${escapeHtml(book.genre || '')}">
                </div>
              </div>
              <div class="form-group">
                <label>ISBN</label>
                <input type="text" id="edit-isbn" value="${escapeHtml(book.isbn || '')}">
              </div>
              <div class="form-group">
                <label>Language</label>
                <select id="edit-language">
                  <option value="en" ${book.language === 'en' ? 'selected' : ''}>English</option>
                  <option value="es" ${book.language === 'es' ? 'selected' : ''}>Spanish</option>
                  <option value="fr" ${book.language === 'fr' ? 'selected' : ''}>French</option>
                  <option value="de" ${book.language === 'de' ? 'selected' : ''}>German</option>
                  <option value="it" ${book.language === 'it' ? 'selected' : ''}>Italian</option>
                  <option value="ja" ${book.language === 'ja' ? 'selected' : ''}>Japanese</option>
                  <option value="zh" ${book.language === 'zh' ? 'selected' : ''}>Chinese</option>
                </select>
              </div>
              <div class="form-group">
                <label>Description</label>
                <textarea id="edit-description" rows="4">${escapeHtml(book.description || '')}</textarea>
              </div>
              ${book.duration ? `
              <div class="audio-info">
                <h4>Audio Information</h4>
                <div class="audio-stats">
                  <span>Duration: ${formatDuration(book.duration)}</span>
                  <span>Bitrate: ${book.bitrate || 'N/A'} kbps</span>
                  <span>Sample Rate: ${book.sampleRate || 'N/A'} Hz</span>
                  <span>Channels: ${book.channels || 'N/A'}</span>
                </div>
              </div>
              ` : ''}
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn" onclick="closeBookEditor(this)">Cancel</button>
            <button class="btn btn-primary" onclick="saveBookChanges(${book.id})">Save Changes</button>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeBookEditor = function(element) {
      const modal = element.closest('.book-editor-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    window.changeBookCover = function(bookId) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
          const base64 = await blobToBase64(file);
          const book = state.books.find(b => b.id === bookId);
          if (book) {
            book.coverBase64 = base64.split(',')[1];
            book.coverMime = file.type;
            renderBooks();
            saveState();
            showToast('Cover updated', 'success');
            closeBookEditor(document.querySelector('.book-editor-modal .btn'));
          }
        }
      };
      input.click();
    };

    window.saveBookChanges = function(bookId) {
      const book = state.books.find(b => b.id === bookId);
      if (!book) return;

      book.title = document.getElementById('edit-title').value;
      book.author = document.getElementById('edit-author').value;
      book.narrator = document.getElementById('edit-narrator').value;
      book.series = document.getElementById('edit-series').value;
      book.year = document.getElementById('edit-year').value;
      book.publisher = document.getElementById('edit-publisher').value;
      book.genre = document.getElementById('edit-genre').value;
      book.isbn = document.getElementById('edit-isbn').value;
      book.language = document.getElementById('edit-language').value;
      book.description = document.getElementById('edit-description').value;

      renderBooks();
      saveState();
      closeBookEditor(document.querySelector('.book-editor-modal .btn'));
      showToast('Book updated successfully', 'success');
    };

    function formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }

    // Batch Operations
    function showBatchOperations() {
      const modal = createBatchModal();
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('show'));
    }

    function createBatchModal() {
      const modal = document.createElement('div');
      modal.className = 'batch-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeBatchModal(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Batch Operations</h2>
            <button class="btn btn-icon" onclick="closeBatchModal(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="batch-section">
              <h3>Export Options</h3>
              <button class="btn" onclick="exportAsJSON()">Export as JSON</button>
              <button class="btn" onclick="exportAsCSV()">Export as CSV</button>
              <button class="btn" onclick="exportCoversOnly()">Export Covers Only</button>
            </div>
            <div class="batch-section">
              <h3>Metadata Operations</h3>
              <button class="btn" onclick="batchFetchMissing()">Fetch Missing Metadata</button>
              <button class="btn" onclick="batchUpdateCovers()">Update All Covers</button>
              <button class="btn btn-danger" onclick="batchClearMetadata()">Clear All Metadata</button>
            </div>
            <div class="batch-section">
              <h3>Library Management</h3>
              <button class="btn" onclick="findDuplicates()">Find Duplicates</button>
              <button class="btn" onclick="organizeBySeries()">Organize by Series</button>
              <button class="btn btn-danger" onclick="batchDelete()">Batch Delete</button>
            </div>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeBatchModal = function(element) {
      const modal = element.closest('.batch-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    // Batch Operations Implementation
    window.exportAsCSV = function() {
      const headers = ['Title', 'Author', 'Format', 'Year', 'Publisher', 'Genre', 'ISBN', 'Language'];
      const csv = [headers.join(',')];
      
      state.books.forEach(book => {
        const row = [
          `"${book.title || ''}"`,
          `"${book.author || ''}"`,
          book.format,
          `"${book.year || ''}"`,
          `"${book.publisher || ''}"`,
          `"${book.genre || ''}"`,
          `"${book.isbn || ''}"`,
          book.language || 'en'
        ];
        csv.push(row.join(','));
      });
      
      downloadFile(csv.join('\n'), 'library.csv', 'text/csv');
      showToast('Library exported as CSV', 'success');
    };

    window.exportCoversOnly = function() {
      const booksWithCovers = state.books.filter(book => book.coverBase64);
      if (booksWithCovers.length === 0) {
        showToast('No books with covers found', 'warning');
        return;
      }
      
      booksWithCovers.forEach((book, index) => {
        const dataUrl = `data:${book.coverMime};base64,${book.coverBase64}`;
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = `${book.title || book.fileName}_cover.${book.coverMime.split('/')[1]}`;
        link.click();
      });
      
      showToast(`Exported ${booksWithCovers.length} covers`, 'success');
    };

    window.batchFetchMissing = async function() {
      const booksNeedingMetadata = state.books.filter(book => 
        !book.author || !book.description || (!book.coverBase64 && book.title)
      );
      
      if (booksNeedingMetadata.length === 0) {
        showToast('All books have complete metadata', 'info');
        return;
      }
      
      showToast(`Updating ${booksNeedingMetadata.length} books...`, 'info');
      
      for (const book of booksNeedingMetadata) {
        try {
          const results = await fetchExternalMetadata(book.title, book.author);
          if (results.length > 0) {
            const bestMatch = results[0];
            Object.assign(book, {
              title: bestMatch.title || book.title,
              author: bestMatch.author || book.author,
              publisher: bestMatch.publisher || book.publisher,
              year: bestMatch.year || book.year,
              genre: bestMatch.genre || book.genre,
              isbn: bestMatch.isbn || book.isbn,
              description: bestMatch.description || book.description
            });
            
            if (bestMatch.coverUrl && !book.coverBase64) {
              try {
                const coverResponse = await fetch(bestMatch.coverUrl);
                const coverBlob = await coverResponse.blob();
                const coverBase64 = await blobToBase64(coverBlob);
                book.coverBase64 = coverBase64.split(',')[1];
                book.coverMime = coverBlob.type;
              } catch (e) {
                console.warn('Cover fetch failed for', book.title);
              }
            }
          }
        } catch (error) {
          console.warn('Metadata fetch failed for', book.title);
        }
      }
      
      renderBooks();
      saveState();
      showToast('Batch metadata update complete', 'success');
    };

    window.findDuplicates = function() {
      const duplicates = [];
      const seen = new Map();
      
      state.books.forEach(book => {
        const key = `${book.title.toLowerCase()}-${book.author?.toLowerCase() || ''}`;
        if (seen.has(key)) {
          duplicates.push({ book, original: seen.get(key) });
        } else {
          seen.set(key, book);
        }
      });
      
      if (duplicates.length === 0) {
        showToast('No duplicates found', 'info');
      } else {
        showToast(`Found ${duplicates.length} potential duplicates`, 'warning');
        // TODO: Show duplicates management modal
      }
    };

    window.batchDelete = function() {
      if (confirm('Are you sure you want to delete all books? This cannot be undone.')) {
        state.books = [];
        renderBooks();
        saveState();
        showToast('All books deleted', 'success');
        closeBatchModal(document.querySelector('.batch-modal .btn'));
      }
    };

    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Advanced Search
    function showAdvancedSearch() {
      const modal = createAdvancedSearchModal();
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('show'));
    }

    function createAdvancedSearchModal() {
      const modal = document.createElement('div');
      modal.className = 'search-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeSearchModal(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Advanced Search</h2>
            <button class="btn btn-icon" onclick="closeSearchModal(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="search-form">
              <div class="form-group">
                <label>Title</label>
                <input type="text" id="search-title" placeholder="Search in titles...">
              </div>
              <div class="form-group">
                <label>Author</label>
                <input type="text" id="search-author" placeholder="Search in authors...">
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Format</label>
                  <select id="search-format">
                    <option value="">All Formats</option>
                    <option value="epub">EPUB</option>
                    <option value="pdf">PDF</option>
                    <option value="mp3">MP3</option>
                    <option value="m4b">M4B</option>
                    <option value="flac">FLAC</option>
                    <option value="ogg">OGG</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>Year</label>
                  <input type="number" id="search-year" placeholder="Year">
                </div>
              </div>
              <div class="form-group">
                <label>Genre</label>
                <input type="text" id="search-genre" placeholder="Search in genres...">
              </div>
              <div class="form-group">
                <label>ISBN</label>
                <input type="text" id="search-isbn" placeholder="ISBN...">
              </div>
              <div class="form-group">
                <label>
                  <input type="checkbox" id="search-has-cover"> Has cover image
                </label>
              </div>
              <div class="form-group">
                <label>
                  <input type="checkbox" id="search-missing-meta"> Missing metadata
                </label>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn" onclick="closeSearchModal(this)">Cancel</button>
            <button class="btn btn-primary" onclick="performAdvancedSearch()">Search</button>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeSearchModal = function(element) {
      const modal = element.closest('.search-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    window.performAdvancedSearch = function() {
      const title = document.getElementById('search-title').value.toLowerCase();
      const author = document.getElementById('search-author').value.toLowerCase();
      const format = document.getElementById('search-format').value;
      const year = document.getElementById('search-year').value;
      const genre = document.getElementById('search-genre').value.toLowerCase();
      const isbn = document.getElementById('search-isbn').value;
      const hasCover = document.getElementById('search-has-cover').checked;
      const missingMeta = document.getElementById('search-missing-meta').checked;
      
      const results = state.books.filter(book => {
        if (title && !book.title.toLowerCase().includes(title)) return false;
        if (author && !book.author?.toLowerCase().includes(author)) return false;
        if (format && book.format !== format) return false;
        if (year && book.year !== year) return false;
        if (genre && !book.genre?.toLowerCase().includes(genre)) return false;
        if (isbn && !book.isbn?.includes(isbn)) return false;
        if (hasCover && !book.coverBase64) return false;
        if (missingMeta && (book.author && book.description)) return false;
        return true;
      });
      
      closeSearchModal(document.querySelector('.search-modal .btn'));
      
      // Show results
      if (results.length === 0) {
        showToast('No books match your search criteria', 'info');
      } else {
        showToast(`Found ${results.length} matching books`, 'success');
        // Temporarily filter the view
        const originalBooks = state.books;
        state.books = results;
        renderBooks();
        
        // Add reset button
        const resetBtn = document.createElement('button');
        resetBtn.className = 'btn btn-secondary';
        resetBtn.textContent = 'Reset Search';
        resetBtn.style.margin = 'var(--spacing-md)';
        resetBtn.onclick = () => {
          state.books = originalBooks;
          renderBooks();
          resetBtn.remove();
        };
        elements.bookGrid.parentNode.insertBefore(resetBtn, elements.bookGrid);
      }
    };

    // Statistics Dashboard
    function showStatistics() {
      const stats = calculateStatistics();
      const modal = createStatsModal(stats);
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('show'));
    }

    function calculateStatistics() {
      const total = state.books.length;
      const formats = {};
      const years = {};
      const authors = {};
      const withCovers = state.books.filter(book => book.coverBase64).length;
      const withMetadata = state.books.filter(book => book.author && book.description).length;
      const audiobooks = state.books.filter(book => ['mp3', 'm4b', 'm4a', 'flac', 'ogg', 'opus'].includes(book.format)).length;
      
      state.books.forEach(book => {
        formats[book.format] = (formats[book.format] || 0) + 1;
        if (book.year) years[book.year] = (years[book.year] || 0) + 1;
        if (book.author) authors[book.author] = (authors[book.author] || 0) + 1;
      });
      
      return {
        total,
        formats,
        years: Object.entries(years).sort((a, b) => b[0] - a[0]).slice(0, 10),
        topAuthors: Object.entries(authors).sort((a, b) => b[1] - a[1]).slice(0, 10),
        withCovers,
        withMetadata,
        audiobooks,
        completionRate: Math.round((withMetadata / total) * 100)
      };
    }

    function createStatsModal(stats) {
      const modal = document.createElement('div');
      modal.className = 'stats-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeStatsModal(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Library Statistics</h2>
            <button class="btn btn-icon" onclick="closeStatsModal(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="stats-grid">
              <div class="stat-card">
                <h3>${stats.total}</h3>
                <p>Total Books</p>
              </div>
              <div class="stat-card">
                <h3>${stats.withCovers}</h3>
                <p>With Covers</p>
              </div>
              <div class="stat-card">
                <h3>${stats.completionRate}%</h3>
                <p>Metadata Complete</p>
              </div>
              <div class="stat-card">
                <h3>${stats.audiobooks}</h3>
                <p>Audiobooks</p>
              </div>
            </div>
            
            <div class="stats-section">
              <h3>Format Distribution</h3>
              ${Object.entries(stats.formats).map(([format, count]) => 
                `<div class="stat-bar">
                  <span class="stat-label">${format.toUpperCase()}</span>
                  <div class="stat-progress">
                    <div class="stat-fill" style="width: ${(count / stats.total) * 100}%"></div>
                  </div>
                  <span class="stat-value">${count}</span>
                </div>`
              ).join('')}
            </div>
            
            <div class="stats-section">
              <h3>Top Authors</h3>
              ${stats.topAuthors.map(([author, count]) => 
                `<div class="author-stat">
                  <span>${escapeHtml(author)}</span>
                  <span>${count} books</span>
                </div>`
              ).join('')}
            </div>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeStatsModal = function(element) {
      const modal = element.closest('.stats-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    // Update settings to include new options
    function updateSettings() {
      const settingsContent = document.querySelector('#settingsTab .settings-scroll');
      if (settingsContent) {
        const newSections = `
          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Advanced Features</h3>
            <button class="btn" id="batchBtn" style="margin-bottom: var(--spacing-sm);">Batch Operations</button>
            <button class="btn" id="advancedSearchBtn" style="margin-bottom: var(--spacing-sm);">Advanced Search</button>
            <button class="btn" id="statsBtn" style="margin-bottom: var(--spacing-sm);">Library Statistics</button>
          </div>
          
          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Import/Export</h3>
            <button class="btn" id="importBtn" style="margin-bottom: var(--spacing-sm);">Import Library</button>
            <button class="btn" id="exportJsonBtn" style="margin-bottom: var(--spacing-sm);">Export as JSON</button>
            <button class="btn" id="exportCsvBtn" style="margin-bottom: var(--spacing-sm);">Export as CSV</button>
          </div>
        `;
        
        settingsContent.insertAdjacentHTML('beforeend', newSections);
        
        // Add event listeners for new buttons
        document.getElementById('batchBtn').addEventListener('click', showBatchOperations);
        document.getElementById('advancedSearchBtn').addEventListener('click', showAdvancedSearch);
        document.getElementById('statsBtn').addEventListener('click', showStatistics);
        document.getElementById('importBtn').addEventListener('click', importLibrary);
        document.getElementById('exportJsonBtn').addEventListener('click', exportLibrary);
        document.getElementById('exportCsvBtn').addEventListener('click', exportAsCSV);
      }
    }

    function importLibrary() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            const text = await file.text();
            const imported = JSON.parse(text);
            if (Array.isArray(imported)) {
              state.books = [...state.books, ...imported];
              renderBooks();
              saveState();
              showToast(`Imported ${imported.length} books`, 'success');
            } else {
              showToast('Invalid file format', 'error');
            }
          } catch (error) {
            showToast('Import failed', 'error');
          }
        }
      };
      input.click();
    }

    // Add modal styles
    const modalStyles = `
      .book-editor-modal, .batch-modal, .search-modal, .stats-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .book-editor-modal.show, .batch-modal.show, .search-modal.show, .stats-modal.show {
        opacity: 1;
      }
      
      .modal-backdrop {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
      }
      
      .modal-content {
        position: relative;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        max-width: 90vw;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: var(--shadow-xl);
      }
      
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border);
      }
      
      .modal-body {
        padding: var(--spacing-md);
        overflow-y: auto;
        max-height: 60vh;
      }
      
      .modal-footer {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: flex-end;
        padding: var(--spacing-md);
        border-top: 1px solid var(--border);
      }
      
      .book-cover-section {
        text-align: center;
        margin-bottom: var(--spacing-lg);
      }
      
      .cover-preview {
        width: 120px;
        height: 160px;
        margin: 0 auto var(--spacing-sm);
        border-radius: var(--radius-md);
        overflow: hidden;
        background: var(--bg-tertiary);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .cover-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .cover-placeholder {
        color: var(--text-muted);
      }
      
      .book-form {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
      }
      
      .form-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
      }
      
      .form-group label {
        font-weight: 500;
        color: var(--text-secondary);
        font-size: 0.875rem;
      }
      
      .form-group input,
      .form-group select,
      .form-group textarea {
        padding: var(--spacing-sm);
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: inherit;
      }
      
      .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-md);
      }
      
      .audio-info {
        background: var(--bg-tertiary);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        margin-top: var(--spacing-md);
      }
      
      .audio-stats {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-md);
        font-size: 0.875rem;
        color: var(--text-secondary);
      }
      
      .batch-section {
        margin-bottom: var(--spacing-lg);
      }
      
      .batch-section h3 {
        margin-bottom: var(--spacing-sm);
        color: var(--text-secondary);
      }
      
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
      }
      
      .stat-card {
        background: var(--bg-tertiary);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        text-align: center;
      }
      
      .stat-card h3 {
        font-size: 2rem;
        font-weight: 700;
        color: var(--primary);
        margin-bottom: var(--spacing-xs);
      }
      
      .stat-card p {
        color: var(--text-secondary);
        font-size: 0.875rem;
      }
      
      .stats-section {
        margin-bottom: var(--spacing-lg);
      }
      
      .stats-section h3 {
        margin-bottom: var(--spacing-md);
        color: var(--text-secondary);
      }
      
      .stat-bar {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-xs);
      }
      
      .stat-label {
        min-width: 60px;
        font-size: 0.875rem;
      }
      
      .stat-progress {
        flex: 1;
        height: 8px;
        background: var(--bg-tertiary);
        border-radius: var(--radius-full);
        overflow: hidden;
      }
      
      .stat-fill {
        height: 100%;
        background: var(--primary);
        transition: width 0.3s ease;
      }
      
      .stat-value {
        min-width: 30px;
        text-align: right;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }
      
      .author-stat {
        display: flex;
        justify-content: space-between;
        padding: var(--spacing-xs) 0;
        border-bottom: 1px solid var(--border);
      }
      
      .author-stat:last-child {
        border-bottom: none;
      }
      
      @media (max-width: 768px) {
        .form-row {
          grid-template-columns: 1fr;
        }
        
        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
        
        .modal-content {
          max-width: 95vw;
          margin: var(--spacing-md);
        }
      }
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.textContent = modalStyles;
    document.head.appendChild(styleSheet);

    // ===== START APP =====
    init();
    updateSettings();
  </script>
</body>
</html>

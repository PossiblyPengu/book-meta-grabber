<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Book Meta Grabber</title>
  
  <style>
    /* ===== REFRESHED MODERN DESIGN SYSTEM ===== */
    
    :root {
      /* Enhanced Color Palette - Richer, more vibrant */
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #818cf8;
      --primary-glow: rgba(99, 102, 241, 0.4);
      --secondary: #a855f7;
      --secondary-light: #c084fc;
      --success: #22c55e;
      --success-light: #4ade80;
      --warning: #f59e0b;
      --warning-light: #fbbf24;
      --error: #ef4444;
      --error-light: #f87171;
      --info: #3b82f6;
      --info-light: #60a5fa;
      
      /* Enhanced Backgrounds - More depth */
      --bg-primary: #0f0f1a;
      --bg-secondary: #1a1a2e;
      --bg-tertiary: #252542;
      --surface: #16162a;
      --surface-elevated: #1e1e3a;
      --surface-hover: #252550;
      --surface-active: #2a2a5c;
      
      /* Enhanced Text - Better contrast */
      --text-primary: #ffffff;
      --text-secondary: #a1a1c0;
      --text-muted: #6b6b8d;
      --text-dim: #4a4a6a;
      --text-inverse: #0f0f1a;
      
      /* Enhanced Borders - Subtle depth */
      --border: rgba(255, 255, 255, 0.08);
      --border-focus: var(--primary);
      --border-glow: rgba(99, 102, 241, 0.3);
      
      /* Enhanced Gradients */
      --gradient-primary: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #a855f7 100%);
      --gradient-surface: linear-gradient(180deg, rgba(255,255,255,0.03) 0%, transparent 100%);
      --gradient-glow: radial-gradient(ellipse at top, rgba(99, 102, 241, 0.15) 0%, transparent 50%);
      
      /* Safe Areas */
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      
      /* Enhanced Spacing - More breathing room */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 12px;
      --spacing-lg: 20px;
      --spacing-xl: 32px;
      --spacing-2xl: 48px;
      
      /* Touch Targets */
      --touch-min: 44px;
      --touch-comfortable: 48px;
      
      /* Enhanced Typography - Modern font stack */
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
      --font-display: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      
      /* Enhanced Shadows - Better depth perception */
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3), 0 1px 3px 0 rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.2);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.5), 0 4px 6px -4px rgb(0 0 0 / 0.3);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.6), 0 8px 10px -6px rgb(0 0 0 / 0.4);
      --shadow-glow: 0 0 20px rgba(99, 102, 241, 0.3), 0 0 40px rgba(99, 102, 241, 0.1);
      --shadow-inset: inset 0 2px 4px 0 rgb(0 0 0 / 0.3);
      
      /* Enhanced Transitions - Smoother animations */
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 200ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-bounce: 400ms cubic-bezier(0.34, 1.56, 0.64, 1);
      
      /* Enhanced Border Radius - More modern */
      --radius-xs: 4px;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --radius-full: 9999px;
    }
    
    /* ===== BASE STYLES - Modernized ===== */
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html {
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
      scroll-behavior: smooth;
    }
    
    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      background-image: var(--gradient-glow);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--surface-elevated);
      border-radius: var(--radius-full);
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-light);
    }
    
    /* ===== ENHANCED LAYOUT COMPONENTS ===== */
    
    .app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding-top: var(--safe-top);
      padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left);
      padding-right: var(--safe-right);
      position: relative;
    }
    
    .app::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-glow);
      pointer-events: none;
      z-index: -1;
    }
    
    .header {
      background: var(--surface);
      background-image: var(--gradient-surface);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md) var(--spacing-lg);
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      box-shadow: var(--shadow-md);
    }
    
    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .title {
      font-size: 1.75rem;
      font-weight: 800;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
    }
    
    .header-actions {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .main {
      flex: 1;
      padding: var(--spacing-lg);
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      overflow-y: auto;
    }
    
    /* ===== MODERN TAB BAR ===== */
    
    .tab-bar {
      background: var(--surface);
      background-image: var(--gradient-surface);
      border-top: 1px solid var(--border);
      display: flex;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 100;
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      box-shadow: var(--shadow-xl);
      padding-bottom: var(--safe-bottom);
    }
    
    .tab-button {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      min-height: var(--touch-comfortable);
      transition: all var(--transition-bounce);
      position: relative;
      overflow: hidden;
    }
    
    .tab-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%) scaleX(0);
      width: 60%;
      height: 3px;
      background: var(--gradient-primary);
      border-radius: var(--radius-full);
      transition: transform var(--transition-bounce);
    }
    
    .tab-button:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.03);
    }
    
    .tab-button.active {
      color: var(--primary-light);
    }
    
    .tab-button.active::before {
      transform: translateX(-50%) scaleX(1);
    }
    
    .tab-button.active .tab-icon {
      filter: drop-shadow(0 0 8px var(--primary-glow));
    }
    
    .tab-icon {
      width: 24px;
      height: 24px;
      transition: all var(--transition-normal);
    }
    
    .tab-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    
    /* ===== MODERN BUTTONS ===== */
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--surface-elevated);
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      min-height: var(--touch-min);
      transition: all var(--transition-normal);
      text-decoration: none;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-surface);
      opacity: 0;
      transition: opacity var(--transition-fast);
    }
    
    .btn:hover {
      background: var(--surface-hover);
      border-color: var(--primary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-glow);
    }
    
    .btn:hover::before {
      opacity: 1;
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow-inset);
    }
    
    .btn-primary {
      background: var(--gradient-primary);
      color: white;
      border-color: transparent;
      box-shadow: var(--shadow-md), 0 0 20px rgba(99, 102, 241, 0.3);
    }
    
    .btn-primary:hover {
      box-shadow: var(--shadow-lg), 0 0 30px rgba(99, 102, 241, 0.5);
      transform: translateY(-2px);
    }
    
    .btn-icon {
      padding: var(--spacing-sm);
      aspect-ratio: 1;
      border-radius: var(--radius-md);
    }
    
    .btn-icon svg {
      width: 20px;
      height: 20px;
    }
    
    /* ===== LAYOUT COMPONENTS ===== */
    
    .app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding-top: var(--safe-top);
      padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left);
      padding-right: var(--safe-right);
    }
    
    .header {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md);
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    
    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 100%;
    }
    
    .title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
    }
    
    .header-actions {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .quick-search {
      position: relative;
      display: flex;
      align-items: center;
    }

    #quickSearchInput {
      width: 200px;
      padding: var(--spacing-sm);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--surface);
      color: var(--text-primary);
      font-size: 0.875rem;
      transition: all var(--transition-fast);
    }

    #quickSearchInput:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .view-options {
      display: flex;
      gap: var(--spacing-xs);
      padding: 0 var(--spacing-sm);
      border-left: 1px solid var(--border);
    }

    /* ===== QOL FEATURES ===== */
    
    .stats-bar {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-sm) var(--spacing-md);
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .stats-info {
      display: flex;
      gap: var(--spacing-md);
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    .stat-value {
      font-weight: 600;
      color: var(--text-primary);
    }

    .quick-filters {
      display: flex;
      gap: var(--spacing-xs);
    }

    .quick-filter-btn {
      padding: var(--spacing-xs) var(--spacing-sm);
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .quick-filter-btn:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .quick-filter-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    /* Enhanced Grid Sizes */
    .book-grid.grid-small {
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    }

    .book-grid.grid-medium {
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }

    .book-grid.grid-large {
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    }

    /* Compact View */
    .book-grid.compact .book-card {
      flex-direction: row;
      height: auto;
      padding: var(--spacing-sm);
    }

    .book-grid.compact .book-cover {
      width: 40px;
      height: 60px;
      margin: 0;
    }

    .book-grid.compact .book-info {
      flex: 1;
      text-align: left;
    }

    .book-grid.compact .book-format {
      position: static;
      margin-left: var(--spacing-sm);
    }

    /* Sort Dropdown */
    .sort-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      min-width: 200px;
      display: none;
    }

    .sort-dropdown.active {
      display: block;
    }

    .sort-option {
      padding: var(--spacing-sm) var(--spacing-md);
      cursor: pointer;
      transition: background var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sort-option:hover {
      background: var(--surface-elevated);
    }

    .sort-option.active {
      background: var(--primary);
      color: white;
    }

    .sort-direction {
      font-size: 0.75rem;
      opacity: 0.7;
    }

    /* Keyboard Shortcuts Help */
    .shortcuts-help {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl);
      z-index: 10000;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      display: none;
    }

    .shortcuts-help.active {
      display: block;
    }

    .shortcuts-header {
      padding: var(--spacing-lg);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .shortcuts-content {
      padding: var(--spacing-lg);
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) 0;
      border-bottom: 1px solid var(--border);
    }

    .shortcut-item:last-child {
      border-bottom: none;
    }

    .shortcut-key {
      background: var(--surface-elevated);
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-sm);
      font-family: var(--font-mono);
      font-size: 0.75rem;
      color: var(--text-primary);
    }

    .shortcut-desc {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    /* Recent Searches */
    .recent-searches {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }

    .recent-searches.active {
      display: block;
    }

    .recent-search-item {
      padding: var(--spacing-sm) var(--spacing-md);
      cursor: pointer;
      transition: background var(--transition-fast);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }

    .recent-search-item:hover {
      background: var(--surface-elevated);
    }

    .recent-search-text {
      flex: 1;
      color: var(--text-primary);
      font-size: 0.875rem;
    }

    .recent-search-remove {
      color: var(--text-muted);
      cursor: pointer;
      padding: var(--spacing-xs);
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
    }

    .recent-search-remove:hover {
      background: var(--error);
      color: white;
    }
    
    .main {
      flex: 1;
      padding: var(--spacing-md);
      overflow-y: auto;
    }
    
    .tab-bar {
      background: var(--surface);
      border-top: 1px solid var(--border);
      display: flex;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 100;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    
    .tab-button {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm);
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      min-height: var(--touch-comfortable);
      transition: all var(--transition-fast);
      position: relative;
    }
    
    .tab-button:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.05);
    }
    
    .tab-button.active {
      color: var(--primary);
    }
    
    .tab-button.active::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 32px;
      height: 3px;
      background: var(--primary);
      border-radius: var(--radius-full);
    }
    
    .tab-icon {
      width: 24px;
      height: 24px;
    }
    
    .tab-label {
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    /* ===== TAB SCREENS ===== */
    
    .tab-screen {
      display: none;
      padding-bottom: 80px; /* Space for tab bar */
    }
    
    .tab-screen.active {
      display: block;
    }
    
    /* ===== BUTTONS ===== */
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--surface);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      min-height: var(--touch-min);
      transition: all var(--transition-fast);
      text-decoration: none;
    }
    
    .btn:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
      transform: translateY(-1px);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    
    .btn-primary:hover {
      background: var(--primary-dark);
      border-color: var(--primary-dark);
    }
    
    .btn-icon {
      padding: var(--spacing-sm);
      aspect-ratio: 1;
    }
    
    /* ===== BOOK GRID ===== */
    
    .book-grid {
      display: grid;
      gap: var(--spacing-lg);
      grid-template-columns: 1fr;
      padding-bottom: 80px;
    }
    
    .book-card {
      background: var(--surface);
      background-image: var(--gradient-surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      display: flex;
      gap: var(--spacing-lg);
      cursor: pointer;
      transition: all var(--transition-slow);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
    }
    
    .book-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity var(--transition-normal);
    }
    
    .book-card::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 0%, rgba(99, 102, 241, 0.1) 0%, transparent 50%);
      opacity: 0;
      transition: opacity var(--transition-slow);
      pointer-events: none;
    }
    
    .book-card:hover {
      background: var(--surface-hover);
      border-color: var(--primary);
      transform: translateY(-4px) scale(1.01);
      box-shadow: var(--shadow-xl), var(--shadow-glow);
    }
    
    .book-card:hover::before {
      opacity: 1;
    }
    
    .book-card:hover::after {
      opacity: 1;
    }
    
    .book-card:active {
      transform: translateY(-2px) scale(1);
    }
    
    .book-cover {
      width: 80px;
      height: 110px;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, var(--surface-elevated) 0%, var(--bg-tertiary) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
      box-shadow: var(--shadow-md);
      position: relative;
    }
    
    .book-cover::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, transparent 50%);
      pointer-events: none;
    }
    
    .book-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform var(--transition-slow);
    }
    
    .book-card:hover .book-cover img {
      transform: scale(1.05);
    }
    
    .book-info {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: var(--spacing-xs);
    }
    
    .book-title {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--text-primary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      line-height: 1.3;
    }
    
    .book-author {
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-weight: 500;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .book-meta {
      display: flex;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-xs);
    }
    
    .book-format {
      background: var(--gradient-primary);
      color: white;
      padding: 3px 8px;
      border-radius: var(--radius-sm);
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }
    
    .book-status-badge {
      padding: 3px 8px;
      border-radius: var(--radius-sm);
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .book-status-unread {
      background: var(--surface-elevated);
      color: var(--text-muted);
    }
    
    .book-status-reading {
      background: rgba(59, 130, 246, 0.2);
      color: var(--info-light);
    }
    
    .book-status-finished {
      background: rgba(34, 197, 94, 0.2);
      color: var(--success-light);
    }
    
    .book-progress-bar {
      width: 100%;
      height: 4px;
      background: var(--surface-elevated);
      border-radius: var(--radius-full);
      margin-top: var(--spacing-sm);
      overflow: hidden;
    }
    
    .book-progress-fill {
      height: 100%;
      background: var(--gradient-primary);
      border-radius: var(--radius-full);
      transition: width var(--transition-slow);
    }
    
    /* ===== MODERN FILTER BAR ===== */
    
    .filter-bar {
      display: flex;
      gap: var(--spacing-sm);
      padding: var(--spacing-lg);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
      background: var(--surface);
      background-image: var(--gradient-surface);
      border-bottom: 1px solid var(--border);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-lg);
    }
    
    .filter-bar::-webkit-scrollbar {
      display: none;
    }
    
    .filter-chip {
      display: inline-flex;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--surface-elevated);
      border: 1px solid var(--border);
      border-radius: var(--radius-full);
      color: var(--text-secondary);
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .filter-chip:hover {
      background: var(--surface-hover);
      border-color: var(--primary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    
    .filter-chip.active {
      background: var(--gradient-primary);
      border-color: transparent;
      color: white;
      box-shadow: var(--shadow-glow);
    }
    
    /* ===== MODERN EMPTY STATE ===== */
    
    .empty-state {
      text-align: center;
      padding: var(--spacing-2xl) var(--spacing-lg);
      color: var(--text-muted);
      background: var(--surface);
      background-image: var(--gradient-surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      margin: var(--spacing-lg);
    }
    
    .empty-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto var(--spacing-lg);
      opacity: 0.5;
      filter: drop-shadow(0 4px 20px rgba(99, 102, 241, 0.2));
    }
    
    .empty-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: var(--spacing-sm);
      color: var(--text-secondary);
    }
    
    .empty-description {
      margin-bottom: var(--spacing-lg);
      line-height: 1.7;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    
    /* ===== BATCH OPERATIONS ===== */
    
    .batch-actions {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md);
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .batch-info {
      flex: 1;
      font-weight: 500;
      color: var(--text-primary);
    }

    .batch-buttons {
      display: flex;
      gap: var(--spacing-sm);
    }

    .book-card {
      position: relative;
    }

    .book-card.select-mode {
      cursor: pointer;
    }

    .book-card.select-mode::before {
      content: '';
      position: absolute;
      top: var(--spacing-sm);
      left: var(--spacing-sm);
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--surface);
      z-index: 10;
      transition: all var(--transition-fast);
    }

    .book-card.select-mode.selected::before {
      background: var(--primary);
      border-color: var(--primary);
    }

    .book-card.select-mode.selected::after {
      content: '‚úì';
      position: absolute;
      top: var(--spacing-sm);
      left: var(--spacing-sm);
      width: 20px;
      height: 20px;
      color: white;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 11;
    }
    
    /* ===== EMPTY STATE ===== */
    
    .empty-state {
      text-align: center;
      padding: var(--spacing-xl) var(--spacing-md);
      color: var(--text-muted);
    }
    
    .empty-icon {
      width: 64px;
      height: 64px;
      margin: 0 auto var(--spacing-md);
      opacity: 0.5;
    }
    
    .empty-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: var(--spacing-sm);
      color: var(--text-secondary);
    }
    
    .empty-description {
      margin-bottom: var(--spacing-lg);
      line-height: 1.6;
    }
    
    /* ===== RESPONSIVE DESIGN ===== */
    
    @media (min-width: 768px) {
      .book-grid {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
      
      .book-card {
        flex-direction: column;
        text-align: center;
      }
      
      .book-cover {
        width: 120px;
        height: 160px;
        margin: 0 auto var(--spacing-md);
      }
      
      .book-info {
        text-align: center;
      }
    }
    
    @media (min-width: 1024px) {
      .main {
        max-width: 1200px;
        margin: 0 auto;
      }
      
      .book-grid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      }
    }
    
    /* ===== ACCESSIBILITY ===== */
    
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    
    /* ===== UTILITIES ===== */
    
    .text-center { text-align: center; }
    .mt-sm { margin-top: var(--spacing-sm); }
    .mt-md { margin-top: var(--spacing-md); }
    .mt-lg { margin-top: var(--spacing-lg); }

    /* ===== THEME TOGGLE ===== */
    .theme-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .theme-btn:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
      color: var(--text-primary);
    }

    .theme-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .theme-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Light theme overrides */
    [data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #f1f5f9;
      --surface: #ffffff;
      --surface-elevated: #f8fafc;
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --text-dim: #94a3b8;
      --border: rgba(0, 0, 0, 0.1);
      --border-focus: var(--primary);
    }

    [data-theme="light"] .editor-backdrop {
      background: rgba(0, 0, 0, 0.5);
    }

    [data-theme="light"] .editor-hero-overlay {
      background: linear-gradient(to bottom, 
        rgba(255, 255, 255, 0.95) 0%, 
        rgba(255, 255, 255, 0.85) 50%, 
        rgba(255, 255, 255, 0.95) 100%
      );
    }

    /* ===== METADATA EDITOR ===== */
    .editor-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      display: none;
    }

    .editor-modal.active {
      display: block;
    }

    .editor-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .editor-sheet {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      transform: translateY(100%);
      transition: transform var(--transition-slow) cubic-bezier(0.34, 1.2, 0.64, 1);
    }

    .editor-modal.active .editor-sheet {
      transform: translateY(0);
    }

    .editor-hero {
      position: relative;
      height: 300px;
      background: var(--surface);
      overflow: hidden;
    }

    .editor-cover-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--spacing-md);
    }

    .editor-cover {
      width: 120px;
      height: 160px;
      border-radius: var(--radius-md);
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-shadow: var(--shadow-xl);
      position: relative;
    }

    .editor-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .editor-cover-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      color: var(--text-muted);
    }

    .editor-cover-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .editor-cover-btn {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .editor-cover-btn:hover {
      background: var(--surface-elevated);
      border-color: var(--primary);
    }

    .editor-cover-btn svg {
      width: 16px;
      height: 16px;
    }

    .editor-hero-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, 
        rgba(15, 23, 42, 0.9) 0%, 
        rgba(15, 23, 42, 0.7) 50%, 
        rgba(15, 23, 42, 0.95) 100%
      );
    }

    .editor-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
      padding-top: calc(var(--spacing-md) + 60px); /* Space for header */
    }

    .editor-header {
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: var(--spacing-md);
      margin: calc(-60px - var(--spacing-md)) -var(--spacing-md) var(--spacing-md) -var(--spacing-md);
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 10;
    }

    .editor-close-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: var(--radius-md);
      transition: all var(--transition-fast);
    }

    .editor-close-btn:hover {
      background: var(--surface);
      color: var(--text-primary);
    }

    .editor-close-btn svg {
      width: 20px;
      height: 20px;
    }

    .editor-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .editor-actions {
      display: flex;
      gap: var(--spacing-sm);
    }

    .editor-search-results {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-md);
      max-height: 300px;
      overflow-y: auto;
    }

    .editor-search-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--border);
    }

    .editor-search-header h3 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .editor-search-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 1.5rem;
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-md);
      transition: all var(--transition-fast);
    }

    .editor-search-close:hover {
      background: var(--surface-elevated);
      color: var(--text-primary);
    }

    .editor-search-list {
      padding: var(--spacing-sm);
    }

    .editor-search-item {
      display: flex;
      gap: var(--spacing-md);
      padding: var(--spacing-sm);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .editor-search-item:hover {
      background: var(--surface-elevated);
    }

    .editor-search-item-cover {
      width: 40px;
      height: 60px;
      border-radius: var(--radius-sm);
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }

    .editor-search-item-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .editor-search-item-info {
      flex: 1;
      min-width: 0;
    }

    .editor-search-item-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--spacing-xs);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .editor-search-item-author {
      color: var(--text-secondary);
      font-size: 0.875rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .editor-form {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .editor-form-group {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-xs);
    }

    .editor-form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
    }

    .editor-label {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .editor-input,
    .editor-select,
    .editor-textarea {
      padding: var(--spacing-sm);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--surface);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.875rem;
      transition: all var(--transition-fast);
    }

    .editor-input:focus,
    .editor-select:focus,
    .editor-textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .editor-textarea {
      resize: vertical;
      min-height: 100px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .editor-form-row {
        grid-template-columns: 1fr;
      }
      
      .editor-hero {
        height: 250px;
      }
      
      .editor-cover {
        width: 100px;
        height: 133px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="header-content">
        <h1 class="title">Book Meta Grabber</h1>
        <div class="header-actions">
          <!-- Quick Search Bar -->
          <div class="quick-search" id="quickSearch">
            <input 
              type="search" 
              id="quickSearchInput"
              placeholder="Quick search... (Ctrl+K)"
              style="display: none;"
            >
            <button class="btn btn-icon" id="quickSearchBtn" aria-label="Quick Search">
              <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
              </svg>
            </button>
          </div>
          
          <!-- View Options -->
          <div class="view-options">
            <button class="btn btn-icon" id="sortBtn" aria-label="Sort">
              <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M3 6h18M7 12h10m-7 6h14"/>
              </svg>
            </button>
            <button class="btn btn-icon" id="gridSizeBtn" aria-label="Grid Size">
              <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="3" width="7" height="7"/>
                <rect x="14" y="3" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/>
                <rect x="3" y="14" width="7" height="7"/>
              </svg>
            </button>
            <button class="btn btn-icon" id="viewModeBtn" aria-label="View Mode">
              <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
              </svg>
            </button>
          </div>
          
          <button class="btn btn-icon" id="searchBtn" aria-label="Search">
            <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="11" cy="11" r="8"/>
              <path d="m21 21-4.35-4.35"/>
            </svg>
          </button>
          <button class="btn btn-icon" id="addBtn" aria-label="Add Book">
            <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="5" x2="12" y2="19"/>
              <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
          </button>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Library Tab -->
      <div class="tab-screen active" id="libraryTab">
        <!-- Stats Bar -->
        <div class="stats-bar">
          <div class="stats-info">
            <div class="stat-item">
              <span>Total Books:</span>
              <span class="stat-value" id="totalBooks">0</span>
            </div>
            <div class="stat-item">
              <span>Reading:</span>
              <span class="stat-value" id="readingCount">0</span>
            </div>
            <div class="stat-item">
              <span>Finished:</span>
              <span class="stat-value" id="finishedCount">0</span>
            </div>
          </div>
          <div class="quick-filters">
            <button class="quick-filter-btn" data-filter="favorites">‚≠ê Favorites</button>
            <button class="quick-filter-btn" data-filter="recent">üïê Recent</button>
            <button class="quick-filter-btn" data-filter="unfinished">üìñ Unfinished</button>
            <button class="quick-filter-btn" id="shortcutsHelpBtn">‚å®Ô∏è Shortcuts</button>
          </div>
        </div>

        <!-- Filter Bar -->
        <div class="filter-bar">
          <button class="filter-chip active" data-format="all">All</button>
          <button class="filter-chip" data-format="epub">EPUB</button>
          <button class="filter-chip" data-format="pdf">PDF</button>
          <button class="filter-chip" data-format="mp3">MP3</button>
          <button class="filter-chip" data-format="m4b">M4B</button>
          <button class="filter-chip" data-format="flac">FLAC</button>
          <button class="filter-chip" data-format="ogg">OGG</button>
          <button class="filter-chip" id="selectModeBtn">Select</button>
        </div>

        <!-- Batch Actions Bar -->
        <div class="batch-actions" id="batchActions" style="display: none;">
          <div class="batch-info">
            <span id="selectedCount">0</span> books selected
          </div>
          <div class="batch-buttons">
            <button class="btn" id="batchEditBtn">Edit All</button>
            <button class="btn" id="batchExportBtn">Export</button>
            <button class="btn" id="batchDeleteBtn" style="color: var(--error); border-color: var(--error);">Delete</button>
          </div>
          <button class="btn btn-icon" id="batchCancelBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>

        <!-- Book Grid -->
        <div class="book-grid" id="bookGrid">
          <!-- Books will be rendered here -->
        </div>

        <!-- Sort Dropdown -->
        <div class="sort-dropdown" id="sortDropdown">
          <div class="sort-option" data-sort="title">
            <span>Title</span>
            <span class="sort-direction" id="titleDirection">‚Üï</span>
          </div>
          <div class="sort-option" data-sort="author">
            <span>Author</span>
            <span class="sort-direction" id="authorDirection">‚Üï</span>
          </div>
          <div class="sort-option" data-sort="addedDate">
            <span>Date Added</span>
            <span class="sort-direction" id="addedDateDirection">‚Üï</span>
          </div>
          <div class="sort-option" data-sort="progress">
            <span>Progress</span>
            <span class="sort-direction" id="progressDirection">‚Üï</span>
          </div>
          <div class="sort-option" data-sort="year">
            <span>Year</span>
            <span class="sort-direction" id="yearDirection">‚Üï</span>
          </div>
        </div>

        <!-- Recent Searches Dropdown -->
        <div class="recent-searches" id="recentSearches">
          <!-- Recent searches will appear here -->
        </div>

        <!-- Keyboard Shortcuts Help -->
        <div class="shortcuts-help" id="shortcutsHelp">
          <div class="shortcuts-header">
            <h3>Keyboard Shortcuts</h3>
            <button class="btn btn-icon" id="closeShortcutsHelp">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="shortcuts-content">
            <div class="shortcut-item">
              <span class="shortcut-desc">Quick Search</span>
              <span class="shortcut-key">Ctrl+K</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Add Book</span>
              <span class="shortcut-key">Ctrl+N</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Export Library</span>
              <span class="shortcut-key">Ctrl+E</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Filter Library</span>
              <span class="shortcut-key">Ctrl+F</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Toggle Dark Mode</span>
              <span class="shortcut-key">Ctrl+D</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Save Current</span>
              <span class="shortcut-key">Ctrl+S</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Close Modal</span>
              <span class="shortcut-key">Escape</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-desc">Delete Selected</span>
              <span class="shortcut-key">Delete</span>
            </div>
          </div>
        </div>

        <!-- Empty State -->
        <div class="empty-state" id="emptyState" style="display: none;">
          <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
          </svg>
          <h2 class="empty-title">No books yet</h2>
          <p class="empty-description">
            Tap the + button to add books from your device, iCloud Drive, or Google Drive.
          </p>
          <button class="btn btn-primary" id="emptyAddBtn">Add Your First Book</button>
        </div>
      </div>

      <!-- Search Tab -->
      <div class="tab-screen" id="searchTab">
        <div style="padding: var(--spacing-md);">
          <h2 style="margin-bottom: var(--spacing-md);">Search Metadata</h2>
          <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
            Search for book metadata from multiple sources including Google Books, Open Library, iTunes, and MusicBrainz.
          </p>
          <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-md);">
            <input 
              type="search" 
              id="searchInput"
              placeholder="Search by title, author, or ISBN..."
              style="flex: 1; padding: var(--spacing-sm); border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--surface); color: var(--text-primary);"
            >
            <button class="btn btn-primary" id="searchSubmitBtn">Search</button>
          </div>
          <div id="searchResults" style="margin-top: var(--spacing-md);">
            <!-- Search results will appear here -->
          </div>
        </div>
      </div>

      <!-- Settings Tab -->
      <div class="tab-screen" id="settingsTab">
        <div style="padding: var(--spacing-md);">
          <h2 style="margin-bottom: var(--spacing-lg);">Settings</h2>
          
          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Appearance</h3>
            <div style="display: flex; align-items: center; justify-content: space-between;">
              <label style="color: var(--text-secondary);">Theme</label>
              <div style="display: flex; gap: var(--spacing-sm);">
                <button class="theme-btn" id="lightThemeBtn" data-theme="light">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <line x1="12" y1="1" x2="12" y2="3"/>
                    <line x1="12" y1="21" x2="12" y2="23"/>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                    <line x1="1" y1="12" x2="3" y2="12"/>
                    <line x1="21" y1="12" x2="23" y2="12"/>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                  </svg>
                  Light
                </button>
                <button class="theme-btn" id="darkThemeBtn" data-theme="dark">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                  </svg>
                  Dark
                </button>
              </div>
            </div>
          </div>

          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Google Drive Integration</h3>
            <div style="margin-bottom: var(--spacing-sm);">
              <label style="display: block; margin-bottom: var(--spacing-xs); color: var(--text-secondary);">OAuth Client ID</label>
              <input 
                type="text" 
                id="gdriveInput"
                placeholder="Enter your Google OAuth Client ID"
                style="width: 100%; padding: var(--spacing-sm); border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--bg-primary); color: var(--text-primary);"
              >
            </div>
            <p style="font-size: 0.875rem; color: var(--text-muted);">
              Required for Google Drive integration. Create one at console.cloud.google.com
            </p>
          </div>

          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Library Management</h3>
            <div style="margin-bottom: var(--spacing-md);">
              <label style="display: block; margin-bottom: var(--spacing-xs); color: var(--text-secondary);">Export Format</label>
              <select id="exportFormat" style="width: 100%; padding: var(--spacing-sm); border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--bg-primary); color: var(--text-primary);">
                <option value="json">JSON</option>
                <option value="csv">CSV</option>
                <option value="pdf">PDF</option>
              </select>
            </div>
            <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-sm);">
              <button class="btn" id="exportBtn">Export Library</button>
              <button class="btn" id="exportSelectedBtn" style="display: none;">Export Selected</button>
            </div>
            <button class="btn" id="clearLibraryBtn" style="color: var(--error); border-color: var(--error);">Clear All Books</button>
          </div>

          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">About</h3>
            <p style="color: var(--text-secondary); line-height: 1.6;">
              <strong>Book Meta Grabber v2.0</strong><br>
              Extract and enrich metadata from your book collection.<br>
              Supports EPUB, PDF, MP3, M4B, FLAC, and OGG formats.
            </p>
          </div>
        </div>
      </div>
    </main>

    <!-- Tab Bar -->
    <nav class="tab-bar">
      <button class="tab-button active" data-tab="library">
        <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
          <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
        </svg>
        <span class="tab-label">Library</span>
      </button>
      <button class="tab-button" data-tab="search">
        <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.35-4.35"/>
        </svg>
        <span class="tab-label">Search</span>
      </button>
      <button class="tab-button" data-tab="settings">
        <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="3"/>
          <path d="M12 1v6m0 6v6m4.22-13.22 4.24 4.24M1.54 9.54l4.24 4.24M1.54 14.46l4.24-4.24M18.46 14.46l-4.24-4.24"/>
        </svg>
        <span class="tab-label">Settings</span>
      </button>
    </nav>

    <!-- Metadata Editor Modal -->
    <div class="editor-modal" id="editorModal">
      <div class="editor-backdrop" id="editorBackdrop"></div>
      <div class="editor-sheet">
        <!-- Cover Hero Section -->
        <div class="editor-hero" id="editorHero">
          <div class="editor-cover-container">
            <div class="editor-cover" id="editorCover">
              <img id="editorCoverImg" style="display: none;">
              <div class="editor-cover-placeholder" id="editorCoverPlaceholder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                  <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                </svg>
              </div>
            </div>
            <button class="editor-cover-btn" id="editorCoverBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14m-7-7h14"/>
              </svg>
              Change Cover
            </button>
            <input type="file" id="coverInput" accept="image/*" style="display: none;">
          </div>
          <div class="editor-hero-overlay"></div>
        </div>

        <!-- Editor Content -->
        <div class="editor-content">
          <!-- Editor Header -->
          <div class="editor-header">
            <button class="editor-close-btn" id="editorCloseBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
            <h2 class="editor-title">Edit Metadata</h2>
            <div class="editor-actions">
              <button class="btn" id="editorSearchBtn">Search</button>
              <button class="btn btn-primary" id="editorSaveBtn">Save</button>
            </div>
          </div>

          <!-- Search Results (Hidden by default) -->
          <div class="editor-search-results" id="editorSearchResults" style="display: none;">
            <div class="editor-search-header">
              <h3>Search Results</h3>
              <button class="editor-search-close" id="editorSearchClose">√ó</button>
            </div>
            <div class="editor-search-list" id="editorSearchList">
              <!-- Search results will appear here -->
            </div>
          </div>

          <!-- Metadata Form -->
          <div class="editor-form">
            <div class="editor-form-group">
              <label class="editor-label">Title</label>
              <input type="text" class="editor-input" id="editTitle" placeholder="Book title">
            </div>

            <div class="editor-form-group">
              <label class="editor-label">Author</label>
              <input type="text" class="editor-input" id="editAuthor" placeholder="Author name">
            </div>

            <div class="editor-form-row">
              <div class="editor-form-group">
                <label class="editor-label">Narrator</label>
                <input type="text" class="editor-input" id="editNarrator" placeholder="Narrator (for audiobooks)">
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Series</label>
                <input type="text" class="editor-input" id="editSeries" placeholder="Series name">
              </div>
            </div>

            <div class="editor-form-row">
              <div class="editor-form-group">
                <label class="editor-label">Year</label>
                <input type="text" class="editor-input" id="editYear" placeholder="2024">
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Publisher</label>
                <input type="text" class="editor-input" id="editPublisher" placeholder="Publisher name">
              </div>
            </div>

            <div class="editor-form-row">
              <div class="editor-form-group">
                <label class="editor-label">Genre</label>
                <input type="text" class="editor-input" id="editGenre" placeholder="Fiction, Non-fiction, etc.">
              </div>
              <div class="editor-form-group">
                <label class="editor-label">ISBN</label>
                <input type="text" class="editor-input" id="editIsbn" placeholder="978-0123456789">
              </div>
            </div>

            <div class="editor-form-group">
              <label class="editor-label">Language</label>
              <select class="editor-select" id="editLanguage">
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="ru">Russian</option>
                <option value="ja">Japanese</option>
                <option value="zh">Chinese</option>
                <option value="ko">Korean</option>
                <option value="ar">Arabic</option>
                <option value="hi">Hindi</option>
              </select>
            </div>

            <div class="editor-form-group">
              <label class="editor-label">Description</label>
              <textarea class="editor-textarea" id="editDescription" rows="4" placeholder="Book description or summary"></textarea>
            </div>

            <!-- Audio-specific fields -->
            <div class="editor-audio-fields" id="editorAudioFields" style="display: none;">
              <h4 style="margin: var(--spacing-lg) 0 var(--spacing-md); color: var(--text-secondary);">Audio Information</h4>
              <div class="editor-form-row">
                <div class="editor-form-group">
                  <label class="editor-label">Duration</label>
                  <input type="text" class="editor-input" id="editDuration" placeholder="0:00:00" readonly>
                </div>
                <div class="editor-form-group">
                  <label class="editor-label">Bitrate</label>
                  <input type="text" class="editor-input" id="editBitrate" placeholder="320 kbps" readonly>
                </div>
              </div>
            </div>

            <!-- Reading Progress -->
            <div class="editor-progress-fields">
              <h4 style="margin: var(--spacing-lg) 0 var(--spacing-md); color: var(--text-secondary);">Reading Progress</h4>
              <div class="editor-form-row">
                <div class="editor-form-group">
                  <label class="editor-label">Status</label>
                  <select class="editor-select" id="editStatus">
                    <option value="unread">Unread</option>
                    <option value="reading">Reading</option>
                    <option value="finished">Finished</option>
                    <option value="abandoned">Abandoned</option>
                  </select>
                </div>
                <div class="editor-form-group">
                  <label class="editor-label">Progress (%)</label>
                  <input type="number" class="editor-input" id="editProgress" min="0" max="100" placeholder="0">
                </div>
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Current Page / Chapter</label>
                <input type="text" class="editor-input" id="editCurrentPage" placeholder="Page 1 or Chapter 1">
              </div>
              <div class="editor-form-row">
                <div class="editor-form-group">
                  <label class="editor-label">Started</label>
                  <input type="date" class="editor-input" id="editStartDate">
                </div>
                <div class="editor-form-group">
                  <label class="editor-label">Finished</label>
                  <input type="date" class="editor-input" id="editFinishDate">
                </div>
              </div>
              <div class="editor-form-group">
                <label class="editor-label">Notes</label>
                <textarea class="editor-textarea" id="editNotes" rows="3" placeholder="Personal notes about this book..."></textarea>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== APPLICATION STATE =====
    const state = {
      books: [],
      activeTab: 'library',
      filterFormat: 'all',
      settings: {
        gdriveClientId: '',
        theme: 'dark',
        // QOL Settings
        autoSave: true,
        showProgress: true,
        compactView: false,
        sortBy: 'addedDate', // 'title', 'author', 'addedDate', 'progress'
        sortOrder: 'desc', // 'asc', 'desc'
        keyboardShortcuts: true,
        animations: true,
        gridSize: 'medium' // 'small', 'medium', 'large'
      },
      currentEditingBook: null,
      selectMode: false,
      selectedBooks: new Set(),
      // QOL State
      searchQuery: '',
      recentSearches: [],
      favorites: new Set(),
      lastViewedBook: null,
      shortcuts: {
        'Ctrl+K': 'openSearch',
        'Ctrl+N': 'addBook',
        'Ctrl+E': 'exportLibrary',
        'Ctrl+F': 'filterLibrary',
        'Escape': 'closeModal',
        'Ctrl+D': 'toggleDarkMode',
        'Ctrl+S': 'saveCurrent',
        'Delete': 'deleteSelected'
      }
    };

    // ===== DOM REFERENCES =====
    const elements = {
      bookGrid: document.getElementById('bookGrid'),
      emptyState: document.getElementById('emptyState'),
      libraryTab: document.getElementById('libraryTab'),
      searchTab: document.getElementById('searchTab'),
      settingsTab: document.getElementById('settingsTab'),
      searchInput: document.getElementById('searchInput'),
      searchResults: document.getElementById('searchResults'),
      gdriveInput: document.getElementById('gdriveInput'),
      exportFormat: document.getElementById('exportFormat'),
      exportSelectedBtn: document.getElementById('exportSelectedBtn'),
      lightThemeBtn: document.getElementById('lightThemeBtn'),
      darkThemeBtn: document.getElementById('darkThemeBtn'),
      tabButtons: document.querySelectorAll('.tab-button'),
      filterChips: document.querySelectorAll('.filter-chip'),
      // Batch operations
      batchActions: document.getElementById('batchActions'),
      selectedCount: document.getElementById('selectedCount'),
      batchEditBtn: document.getElementById('batchEditBtn'),
      batchExportBtn: document.getElementById('batchExportBtn'),
      batchDeleteBtn: document.getElementById('batchDeleteBtn'),
      batchCancelBtn: document.getElementById('batchCancelBtn'),
      selectModeBtn: document.getElementById('selectModeBtn'),
      // Editor elements
      editorModal: document.getElementById('editorModal'),
      editorBackdrop: document.getElementById('editorBackdrop'),
      editorCloseBtn: document.getElementById('editorCloseBtn'),
      editorSaveBtn: document.getElementById('editorSaveBtn'),
      editorSearchBtn: document.getElementById('editorSearchBtn'),
      editorSearchResults: document.getElementById('editorSearchResults'),
      editorSearchClose: document.getElementById('editorSearchClose'),
      editorSearchList: document.getElementById('editorSearchList'),
      editorCover: document.getElementById('editorCover'),
      editorCoverImg: document.getElementById('editorCoverImg'),
      editorCoverPlaceholder: document.getElementById('editorCoverPlaceholder'),
      editorCoverBtn: document.getElementById('editorCoverBtn'),
      coverInput: document.getElementById('coverInput'),
      editorHero: document.getElementById('editorHero'),
      editorAudioFields: document.getElementById('editorAudioFields'),
      // Progress fields
      editStatus: document.getElementById('editStatus'),
      editProgress: document.getElementById('editProgress'),
      editCurrentPage: document.getElementById('editCurrentPage'),
      editStartDate: document.getElementById('editStartDate'),
      editFinishDate: document.getElementById('editFinishDate'),
      editNotes: document.getElementById('editNotes'),
      // Form inputs
      editTitle: document.getElementById('editTitle'),
      editAuthor: document.getElementById('editAuthor'),
      editNarrator: document.getElementById('editNarrator'),
      editSeries: document.getElementById('editSeries'),
      editYear: document.getElementById('editYear'),
      editPublisher: document.getElementById('editPublisher'),
      editGenre: document.getElementById('editGenre'),
      editIsbn: document.getElementById('editIsbn'),
      editLanguage: document.getElementById('editLanguage'),
      editDescription: document.getElementById('editDescription'),
      editDuration: document.getElementById('editDuration'),
      editBitrate: document.getElementById('editBitrate')
    };

    // ===== INITIALIZATION =====
    function init() {
      loadState();
      setupEventListeners();
      renderBooks();
      updateTabDisplay();
    }

    // ===== STATE MANAGEMENT =====
    function saveState() {
      localStorage.setItem('bookMetaGrabber', JSON.stringify(state));
    }

    function loadState() {
      const saved = localStorage.getItem('bookMetaGrabber');
      if (saved) {
        Object.assign(state, JSON.parse(saved));
      }
    }

    // ===== EVENT LISTENERS =====
    function setupEventListeners() {
      // Tab navigation
      elements.tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tab = button.dataset.tab;
          switchTab(tab);
        });
      });

      // Filter chips
      elements.filterChips.forEach(chip => {
        if (chip.id === 'selectModeBtn') {
          chip.addEventListener('click', toggleSelectMode);
        } else {
          chip.addEventListener('click', () => {
            const format = chip.dataset.format;
            setFilter(format);
          });
        }
      });

      // Header buttons
      document.getElementById('searchBtn').addEventListener('click', () => switchTab('search'));
      document.getElementById('addBtn').addEventListener('click', () => addBook());
      document.getElementById('emptyAddBtn').addEventListener('click', () => addBook());

      // Search
      document.getElementById('searchSubmitBtn').addEventListener('click', () => performSearch());
      elements.searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') performSearch();
      });

      // Settings
      document.getElementById('exportBtn').addEventListener('click', () => exportLibrary());
      document.getElementById('exportSelectedBtn').addEventListener('click', () => exportSelected());
      document.getElementById('clearLibraryBtn').addEventListener('click', () => clearLibrary());
      elements.gdriveInput.addEventListener('change', () => {
        state.settings.gdriveClientId = elements.gdriveInput.value;
        saveState();
      });

      // Settings load
      elements.gdriveInput.value = state.settings.gdriveClientId || '';
      elements.exportFormat.value = state.settings.exportFormat || 'json';

      // Theme
      elements.lightThemeBtn.addEventListener('click', () => setTheme('light'));
      elements.darkThemeBtn.addEventListener('click', () => setTheme('dark'));
      updateThemeUI();

      // Batch operations
      elements.batchCancelBtn.addEventListener('click', exitSelectMode);
      elements.batchEditBtn.addEventListener('click', batchEdit);
      elements.batchExportBtn.addEventListener('click', batchExport);
      elements.batchDeleteBtn.addEventListener('click', batchDelete);

      // Editor event listeners
      elements.editorCloseBtn.addEventListener('click', closeEditor);
      elements.editorBackdrop.addEventListener('click', closeEditor);
      elements.editorSaveBtn.addEventListener('click', saveEditor);
      elements.editorSearchBtn.addEventListener('click', searchInEditor);
      elements.editorSearchClose.addEventListener('click', closeEditorSearch);
      elements.editorCoverBtn.addEventListener('click', () => elements.coverInput.click());
      elements.coverInput.addEventListener('change', handleCoverUpload);
    }

    // ===== TAB MANAGEMENT =====
    function switchTab(tabName) {
      state.activeTab = tabName;
      updateTabDisplay();
      saveState();
    }

    function updateTabDisplay() {
      // Update tab buttons
      elements.tabButtons.forEach(button => {
        button.classList.toggle('active', button.dataset.tab === state.activeTab);
      });

      // Update tab screens
      elements.libraryTab.classList.toggle('active', state.activeTab === 'library');
      elements.searchTab.classList.toggle('active', state.activeTab === 'search');
      elements.settingsTab.classList.toggle('active', state.activeTab === 'settings');
    }

    // ===== FILTER MANAGEMENT =====
    function setFilter(format) {
      state.filterFormat = format;
      updateFilterDisplay();
      renderBooks();
      saveState();
    }

    function updateFilterDisplay() {
      elements.filterChips.forEach(chip => {
        chip.classList.toggle('active', chip.dataset.format === state.filterFormat);
      });
    }

    // ===== BOOK MANAGEMENT =====
    function addBook() {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.epub,.pdf,.mp3,.m4b,.m4a,.flac,.ogg';
      
      input.onchange = (e) => {
        const files = Array.from(e.target.files);
        files.forEach(file => {
          const book = createBookFromFile(file);
          state.books.unshift(book);
        });
        
        renderBooks();
        saveState();
        showToast(`Added ${files.length} book${files.length > 1 ? 's' : ''}`);
      };
      
      input.click();
    }

    function createBookFromFile(file) {
      const format = file.name.split('.').pop().toLowerCase();
      const fileName = file.name.replace(/\.[^/.]+$/, '');
      
      // Enhanced filename parsing for better title/author detection
      const { title, author, series, year } = parseFileName(fileName);
      
      return {
        id: Date.now() + Math.random(),
        fileName: file.name,
        format: format,
        title: title,
        author: author,
        narrator: '',
        series: series,
        year: year,
        publisher: '',
        genre: '',
        isbn: '',
        description: '',
        language: 'en',
        coverBase64: null,
        coverMime: null,
        file: file,
        addedDate: new Date().toISOString(),
        // Reading progress
        status: 'unread',
        progress: 0,
        currentPage: '',
        startDate: '',
        finishDate: '',
        notes: ''
      };
    }

    function parseFileName(fileName) {
      // Remove common patterns and clean up the filename
      let cleaned = fileName
        .replace(/[\[\](){}]/g, ' ') // Remove brackets
        .replace(/[._-]/g, ' ') // Replace dots, underscores, hyphens with spaces
        .replace(/\s+/g, ' ') // Multiple spaces to single space
        .trim();

      // Common patterns to detect and extract metadata
      const patterns = [
        // Series patterns: "Series Name #1" or "Series Name Book 1"
        {
          regex: /^(.+?)(?:\s+(?:#|book)\s*(\d+))$/i,
          handler: (match, title, seriesNum) => ({
            title: title.trim(),
            series: `${title.trim()} #${seriesNum}`,
            author: '',
            year: ''
          })
        },
        // Author first: "Author - Title" or "Author - Title (Year)"
        {
          regex: /^(.+?)\s*[-‚Äì‚Äî]\s*(.+?)(?:\s*\((\d{4})\))?$/,
          handler: (match, author, title, year) => ({
            title: title.trim(),
            author: author.trim(),
            series: '',
            year: year || ''
          })
        },
        // Title first with author in brackets: "Title - Author Name"
        {
          regex: /^(.+?)\s*[-‚Äì‚Äî]\s*(.+?)$/,
          handler: (match, title, author) => {
            // Check if second part looks like an author (shorter, no numbers)
            if (author.split(' ').length <= 3 && !/\d/.test(author)) {
              return {
                title: title.trim(),
                author: author.trim(),
                series: '',
                year: ''
              };
            }
            return null;
          }
        },
        // Year in parentheses: "Title (Year)" or "Title by Author (Year)"
        {
          regex: /^(.+?)\s*\((\d{4})\)\s*(?:by\s*(.+))?$/i,
          handler: (match, title, year, author) => ({
            title: title.trim(),
            author: author ? author.trim() : '',
            series: '',
            year: year
          })
        },
        // Multiple authors separated by & or and: "Title - Author & Author"
        {
          regex: /^(.+?)\s*[-‚Äì‚Äî]\s*(.+?(?:\s+(?:and|&)\s*.+?)?)$/,
          handler: (match, title, authors) => ({
            title: title.trim(),
            author: authors.trim(),
            series: '',
            year: ''
          })
        }
      ];

      // Try each pattern
      for (const pattern of patterns) {
        const match = cleaned.match(pattern.regex);
        if (match) {
          const result = pattern.handler(match, ...match.slice(1));
          if (result) return result;
        }
      }

      // Fallback: try to detect if there are multiple parts that could be title/author
      const parts = cleaned.split(/\s+[-‚Äì‚Äî]\s+/);
      if (parts.length === 2) {
        const [part1, part2] = parts;
        // Heuristic: shorter part is likely the author
        if (part1.length > part2.length && part2.split(' ').length <= 3) {
          return {
            title: part1.trim(),
            author: part2.trim(),
            series: '',
            year: ''
          };
        } else if (part2.length > part1.length && part1.split(' ').length <= 3) {
          return {
            title: part2.trim(),
            author: part1.trim(),
            series: '',
            year: ''
          };
        }
      }

      // Last resort: treat everything as title
      return {
        title: cleaned,
        author: '',
        series: '',
        year: ''
      };
    }

    function clearLibrary() {
      if (confirm('Are you sure you want to clear all books? This cannot be undone.')) {
        state.books = [];
        renderBooks();
        saveState();
        showToast('Library cleared');
      }
    }

    function exportLibrary() {
      const format = elements.exportFormat.value;
      const books = state.books;
      exportBooks(books, format);
    }

    function exportSelected() {
      const format = elements.exportFormat.value;
      const selectedBooks = state.books.filter(book => state.selectedBooks.has(book.id));
      exportBooks(selectedBooks, format);
    }

    function exportBooks(books, format) {
      if (books.length === 0) {
        showToast('No books to export', 'warning');
        return;
      }

      try {
        let content, filename, mimeType;
        
        switch (format) {
          case 'csv':
            content = exportToCSV(books);
            filename = `books-${new Date().toISOString().split('T')[0]}.csv`;
            mimeType = 'text/csv';
            break;
          case 'pdf':
            content = exportToPDF(books);
            filename = `books-${new Date().toISOString().split('T')[0]}.pdf`;
            mimeType = 'application/pdf';
            break;
          default: // json
            content = JSON.stringify(books, null, 2);
            filename = `books-${new Date().toISOString().split('T')[0]}.json`;
            mimeType = 'application/json';
        }

        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        
        showToast(`Exported ${books.length} book${books.length > 1 ? 's' : ''} as ${format.toUpperCase()}`, 'success');
      } catch (error) {
        showToast('Export failed', 'error');
        console.error('Export error:', error);
      }
    }

    function exportToCSV(books) {
      const headers = [
        'Title', 'Author', 'Narrator', 'Series', 'Year', 'Publisher',
        'Genre', 'ISBN', 'Language', 'Format', 'Status', 'Progress (%)',
        'Current Page', 'Start Date', 'Finish Date', 'Added Date', 'Notes'
      ];
      
      const rows = books.map(book => [
        book.title || '',
        book.author || '',
        book.narrator || '',
        book.series || '',
        book.year || '',
        book.publisher || '',
        book.genre || '',
        book.isbn || '',
        book.language || '',
        book.format || '',
        book.status || '',
        book.progress || 0,
        book.currentPage || '',
        book.startDate || '',
        book.finishDate || '',
        book.addedDate || '',
        book.notes || ''
      ]);

      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(cell => `"${cell.toString().replace(/"/g, '""')}"`).join(','))
      ].join('\n');

      return csvContent;
    }

    function exportToPDF(books) {
      // Simple PDF generation using browser capabilities
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        // Load jsPDF dynamically if not available
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        script.onload = () => {
          generatePDFContent(books);
        };
        document.head.appendChild(script);
        showToast('Loading PDF export...', 'info');
        return;
      }
      
      return generatePDFContent(books);
    }

    function generatePDFContent(books) {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Add title
      doc.setFontSize(20);
      doc.text('Book Library Export', 20, 20);
      
      // Add date
      doc.setFontSize(10);
      doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 30);
      
      // Add books
      let yPosition = 50;
      const lineHeight = 10;
      const pageHeight = doc.internal.pageSize.height;
      
      books.forEach((book, index) => {
        // Check if we need a new page
        if (yPosition > pageHeight - 40) {
          doc.addPage();
          yPosition = 20;
        }
        
        // Book title
        doc.setFontSize(12);
        doc.text(`${index + 1}. ${book.title || 'Untitled'}`, 20, yPosition);
        yPosition += lineHeight;
        
        // Book details
        doc.setFontSize(10);
        const details = [
          `Author: ${book.author || 'Unknown'}`,
          `Format: ${book.format?.toUpperCase() || 'Unknown'}`,
          `Status: ${getStatusLabel(book.status)}`
        ];
        
        details.forEach(detail => {
          doc.text(detail, 25, yPosition);
          yPosition += lineHeight * 0.8;
        });
        
        yPosition += lineHeight * 0.5;
      });
      
      return doc.output('blob');
    }

    // ===== THEME FUNCTIONS =====
    function setTheme(theme) {
      state.settings.theme = theme;
      document.documentElement.setAttribute('data-theme', theme);
      updateThemeUI();
      saveState();
      showToast(`Switched to ${theme} theme`, 'success');
    }

    function updateThemeUI() {
      const theme = state.settings.theme || 'dark';
      document.documentElement.setAttribute('data-theme', theme);
      
      // Update button states
      elements.lightThemeBtn.classList.toggle('active', theme === 'light');
      elements.darkThemeBtn.classList.toggle('active', theme === 'dark');
    }

    // ===== RENDERING =====
    function renderBooks() {
      const filteredBooks = state.filterFormat === 'all' 
        ? state.books 
        : state.books.filter(book => book.format === state.filterFormat);

      elements.bookGrid.innerHTML = '';
      elements.emptyState.style.display = filteredBooks.length === 0 ? 'block' : 'none';

      filteredBooks.forEach((book, index) => {
        const card = createBookCard(book, index);
        elements.bookGrid.appendChild(card);
      });
    }

    function createBookCard(book, index) {
      const card = document.createElement('div');
      card.className = 'book-card';
      card.dataset.bookId = book.id;
      card.style.animationDelay = `${index * 50}ms`;
      
      const coverHtml = book.coverBase64 
        ? `<img src="data:${book.coverMime || 'image/jpeg'};base64,${book.coverBase64}" alt="${book.title}">`
        : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.3">
             <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
             <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
           </svg>`;

      card.innerHTML = `
        <div class="book-cover">
          ${coverHtml}
          ${book.progress > 0 ? `<div class="book-progress-indicator">${book.progress}%</div>` : ''}
        </div>
        <div class="book-info">
          <div class="book-title">${escapeHtml(book.title || book.fileName)}</div>
          <div class="book-author">${escapeHtml(book.author || 'Unknown Author')}</div>
          ${book.status !== 'unread' ? `<div class="book-status">${getStatusLabel(book.status)}</div>` : ''}
        </div>
        <div class="book-format">${book.format.toUpperCase()}</div>
      `;

      // Add click handler based on mode
      card.addEventListener('click', (e) => {
        if (state.selectMode) {
          toggleBookSelection(book.id);
        } else {
          openBook(book);
        }
      });

      // Update selection state
      if (state.selectMode) {
        card.classList.add('select-mode');
        if (state.selectedBooks.has(book.id)) {
          card.classList.add('selected');
        }
      }

      return card;
    }

    function getStatusLabel(status) {
      const labels = {
        'unread': 'üìö Unread',
        'reading': 'üìñ Reading',
        'finished': '‚úÖ Finished',
        'abandoned': 'üö´ Abandoned'
      };
      return labels[status] || status;
    }

    // ===== SEARCH =====
    async function performSearch() {
      const query = elements.searchInput.value.trim();
      if (!query) return;

      elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">Searching...</p>';
      
      try {
        // Mock search results for now
        const results = await mockSearch(query);
        renderSearchResults(results);
      } catch (error) {
        elements.searchResults.innerHTML = '<p style="color: var(--error);">Search failed. Please try again.</p>';
      }
    }

    async function mockSearch(query) {
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Mock results
      return [
        {
          title: `${query} - Result 1`,
          author: 'Mock Author',
          year: '2023',
          isbn: '9780000000001'
        },
        {
          title: `${query} - Result 2`, 
          author: 'Another Author',
          year: '2022',
          isbn: '9780000000002'
        }
      ];
    }

    function renderSearchResults(results) {
      if (results.length === 0) {
        elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">No results found.</p>';
        return;
      }

      const html = results.map(result => `
        <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--spacing-md); margin-bottom: var(--spacing-sm);">
          <h4 style="margin-bottom: var(--spacing-xs);">${escapeHtml(result.title)}</h4>
          <p style="color: var(--text-secondary); font-size: 0.875rem;">
            ${escapeHtml(result.author)} ‚Ä¢ ${result.year}
          </p>
          <button class="btn btn-primary" style="margin-top: var(--spacing-sm);">Use This</button>
        </div>
      `).join('');

      elements.searchResults.innerHTML = html;
    }

    // ===== UTILITIES =====
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--surface);
        color: var(--text-primary);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--radius-md);
        border: 1px solid var(--border);
        box-shadow: var(--shadow-lg);
        z-index: 1000;
        animation: slideUp 0.3s ease-out;
      `;
      toast.textContent = message;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideDown 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    function openBook(book) {
      state.currentEditingBook = book;
      populateEditor(book);
      elements.editorModal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    // ===== EDITOR FUNCTIONS =====
    function populateEditor(book) {
      // Basic metadata
      elements.editTitle.value = book.title || '';
      elements.editAuthor.value = book.author || '';
      elements.editNarrator.value = book.narrator || '';
      elements.editSeries.value = book.series || '';
      elements.editYear.value = book.year || '';
      elements.editPublisher.value = book.publisher || '';
      elements.editGenre.value = book.genre || '';
      elements.editIsbn.value = book.isbn || '';
      elements.editLanguage.value = book.language || 'en';
      elements.editDescription.value = book.description || '';

      // Reading progress
      elements.editStatus.value = book.status || 'unread';
      elements.editProgress.value = book.progress || 0;
      elements.editCurrentPage.value = book.currentPage || '';
      elements.editStartDate.value = book.startDate || '';
      elements.editFinishDate.value = book.finishDate || '';
      elements.editNotes.value = book.notes || '';

      // Cover image
      if (book.coverBase64) {
        elements.editorCoverImg.src = `data:${book.coverMime || 'image/jpeg'};base64,${book.coverBase64}`;
        elements.editorCoverImg.style.display = 'block';
        elements.editorCoverPlaceholder.style.display = 'none';
        
        // Set hero background
        elements.editorHero.style.background = `linear-gradient(135deg, 
          rgba(99, 102, 241, 0.1) 0%, 
          rgba(139, 92, 246, 0.1) 100%), 
          url('data:${book.coverMime || 'image/jpeg'};base64,${book.coverBase64}') center/cover`;
      } else {
        elements.editorCoverImg.style.display = 'none';
        elements.editorCoverPlaceholder.style.display = 'flex';
        elements.editorHero.style.background = 'var(--surface)';
      }

      // Audio-specific fields
      const isAudio = ['mp3', 'm4b', 'm4a', 'flac', 'ogg', 'opus'].includes(book.format);
      if (isAudio) {
        elements.editorAudioFields.style.display = 'block';
        elements.editDuration.value = formatDuration(book.duration);
        elements.editBitrate.value = book.bitrate ? `${book.bitrate} kbps` : '';
      } else {
        elements.editorAudioFields.style.display = 'none';
      }
    }

    function closeEditor() {
      elements.editorModal.classList.remove('active');
      document.body.style.overflow = '';
      state.currentEditingBook = null;
      closeEditorSearch();
    }

    function saveEditor() {
      if (!state.currentEditingBook) return;

      // Update book object
      const book = state.currentEditingBook;
      book.title = elements.editTitle.value;
      book.author = elements.editAuthor.value;
      book.narrator = elements.editNarrator.value;
      book.series = elements.editSeries.value;
      book.year = elements.editYear.value;
      book.publisher = elements.editPublisher.value;
      book.genre = elements.editGenre.value;
      book.isbn = elements.editIsbn.value;
      book.language = elements.editLanguage.value;
      book.description = elements.editDescription.value;

      // Reading progress
      book.status = elements.editStatus.value;
      book.progress = parseInt(elements.editProgress.value) || 0;
      book.currentPage = elements.editCurrentPage.value;
      book.startDate = elements.editStartDate.value;
      book.finishDate = elements.editFinishDate.value;
      book.notes = elements.editNotes.value;

      // Auto-update status based on progress
      if (book.progress === 0 && book.status !== 'unread') {
        book.status = 'unread';
      } else if (book.progress > 0 && book.progress < 100 && book.status !== 'reading' && book.status !== 'abandoned') {
        book.status = 'reading';
      } else if (book.progress === 100 && book.status !== 'finished') {
        book.status = 'finished';
        if (!book.finishDate) {
          book.finishDate = new Date().toISOString().split('T')[0];
        }
      }

      // Update the book in the array
      const index = state.books.findIndex(b => b.id === book.id);
      if (index !== -1) {
        state.books[index] = book;
      }

      renderBooks();
      saveState();
      closeEditor();
      showToast('Metadata saved successfully', 'success');
    }

    async function searchInEditor() {
      if (!state.currentEditingBook) return;

      const query = `${elements.editTitle.value} ${elements.editAuthor.value}`.trim();
      if (!query) {
        showToast('Enter a title or author to search', 'warning');
        return;
      }

      elements.editorSearchResults.style.display = 'block';
      elements.editorSearchList.innerHTML = '<p style="color: var(--text-secondary); padding: var(--spacing-md);">Searching...</p>';

      try {
        const results = await fetchExternalMetadata(query, '');
        renderEditorSearchResults(results);
      } catch (error) {
        elements.editorSearchList.innerHTML = '<p style="color: var(--error); padding: var(--spacing-md);">Search failed. Please try again.</p>';
      }
    }

    function renderEditorSearchResults(results) {
      if (results.length === 0) {
        elements.editorSearchList.innerHTML = '<p style="color: var(--text-secondary); padding: var(--spacing-md);">No results found.</p>';
        return;
      }

      const html = results.map(result => `
        <div class="editor-search-item" onclick="applyEditorSearchResult(${JSON.stringify(result).replace(/"/g, '&quot;')})">
          <div class="editor-search-item-cover">
            ${result.coverUrl ? `<img src="${result.coverUrl}" alt="${escapeHtml(result.title)}">` : ''}
          </div>
          <div class="editor-search-item-info">
            <div class="editor-search-item-title">${escapeHtml(result.title)}</div>
            <div class="editor-search-item-author">${escapeHtml(result.author || 'Unknown Author')}</div>
          </div>
        </div>
      `).join('');

      elements.editorSearchList.innerHTML = html;
    }

    function closeEditorSearch() {
      elements.editorSearchResults.style.display = 'none';
      elements.editorSearchList.innerHTML = '';
    }

    async function handleCoverUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      if (!file.type.startsWith('image/')) {
        showToast('Please select an image file', 'error');
        return;
      }

      try {
        const base64 = await fileToBase64(file);
        const book = state.currentEditingBook;
        
        book.coverBase64 = base64.split(',')[1];
        book.coverMime = file.type;

        // Update editor display
        elements.editorCoverImg.src = base64;
        elements.editorCoverImg.style.display = 'block';
        elements.editorCoverPlaceholder.style.display = 'none';
        
        // Update hero background
        elements.editorHero.style.background = `linear-gradient(135deg, 
          rgba(99, 102, 241, 0.1) 0%, 
          rgba(139, 92, 246, 0.1) 100%), 
          url('${base64}') center/cover`;

        showToast('Cover updated', 'success');
      } catch (error) {
        showToast('Failed to upload cover', 'error');
      }
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function formatDuration(seconds) {
      if (!seconds) return '';
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Apply search result to editor form
    window.applyEditorSearchResult = function(result) {
      elements.editTitle.value = result.title || elements.editTitle.value;
      elements.editAuthor.value = result.author || elements.editAuthor.value;
      elements.editPublisher.value = result.publisher || elements.editPublisher.value;
      elements.editYear.value = result.year || elements.editYear.value;
      elements.editGenre.value = result.genre || elements.editGenre.value;
      elements.editIsbn.value = result.isbn || elements.editIsbn.value;
      elements.editDescription.value = result.description || elements.editDescription.value;

      // Fetch cover if available
      if (result.coverUrl && !state.currentEditingBook.coverBase64) {
        fetch(result.coverUrl)
          .then(response => response.blob())
          .then(blob => blobToBase64(blob))
          .then(base64 => {
            const book = state.currentEditingBook;
            book.coverBase64 = base64.split(',')[1];
            book.coverMime = blob.type;

            elements.editorCoverImg.src = base64;
            elements.editorCoverImg.style.display = 'block';
            elements.editorCoverPlaceholder.style.display = 'none';
            
            elements.editorHero.style.background = `linear-gradient(135deg, 
              rgba(99, 102, 241, 0.1) 0%, 
              rgba(139, 92, 246, 0.1) 100%), 
              url('${base64}') center/cover`;
          })
          .catch(() => {
            // Silently fail if cover fetch fails
          });
      }

      closeEditorSearch();
      showToast('Metadata applied from search result', 'success');
    };

    // ===== BATCH OPERATIONS =====
    function toggleSelectMode() {
      state.selectMode = !state.selectMode;
      
      if (state.selectMode) {
        elements.selectModeBtn.classList.add('active');
        elements.selectModeBtn.textContent = 'Cancel';
        elements.batchActions.style.display = 'flex';
        elements.exportSelectedBtn.style.display = 'block';
        state.selectedBooks.clear();
      } else {
        exitSelectMode();
      }
      
      renderBooks();
    }

    function exitSelectMode() {
      state.selectMode = false;
      state.selectedBooks.clear();
      elements.selectModeBtn.classList.remove('active');
      elements.selectModeBtn.textContent = 'Select';
      elements.batchActions.style.display = 'none';
      elements.exportSelectedBtn.style.display = 'none';
      renderBooks();
    }

    function toggleBookSelection(bookId) {
      if (state.selectedBooks.has(bookId)) {
        state.selectedBooks.delete(bookId);
      } else {
        state.selectedBooks.add(bookId);
      }
      
      updateBatchUI();
    }

    function updateBatchUI() {
      const count = state.selectedBooks.size;
      elements.selectedCount.textContent = count;
      
      // Update card selection states
      document.querySelectorAll('.book-card').forEach(card => {
        const bookId = card.dataset.bookId;
        if (state.selectedBooks.has(bookId)) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });
    }

    function batchEdit() {
      if (state.selectedBooks.size === 0) {
        showToast('No books selected', 'warning');
        return;
      }
      
      if (state.selectedBooks.size === 1) {
        // Single book - open regular editor
        const bookId = Array.from(state.selectedBooks)[0];
        const book = state.books.find(b => b.id === bookId);
        if (book) openBook(book);
      } else {
        // Multiple books - show batch edit dialog
        showToast('Batch editing coming soon!', 'info');
      }
    }

    function batchExport() {
      if (state.selectedBooks.size === 0) {
        showToast('No books selected', 'warning');
        return;
      }
      
      const selectedBooks = state.books.filter(book => state.selectedBooks.has(book.id));
      const data = JSON.stringify(selectedBooks, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `selected-books-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast(`Exported ${state.selectedBooks.size} book${state.selectedBooks.size > 1 ? 's' : ''}`, 'success');
    }

    function batchDelete() {
      if (state.selectedBooks.size === 0) {
        showToast('No books selected', 'warning');
        return;
      }
      
      const count = state.selectedBooks.size;
      if (!confirm(`Are you sure you want to delete ${count} book${count > 1 ? 's' : ''}? This cannot be undone.`)) {
        return;
      }
      
      // Remove selected books
      state.books = state.books.filter(book => !state.selectedBooks.has(book.id));
      
      exitSelectMode();
      renderBooks();
      saveState();
      showToast(`Deleted ${count} book${count > 1 ? 's' : ''}`, 'success');
    }

    // ===== ANIMATIONS =====
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideUp {
        from { transform: translate(-50%, 100px); opacity: 0; }
        to { transform: translate(-50%, 0); opacity: 1; }
      }
      @keyframes slideDown {
        from { transform: translate(-50%, 0); opacity: 1; }
        to { transform: translate(-50%, 100px); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // ===== METADATA EXTRACTION =====
    async function extractMetadata(file) {
      const format = file.name.split('.').pop().toLowerCase();
      const book = createBookFromFile(file);
      
      try {
        switch (format) {
          case 'epub':
            return await extractEpubMetadata(file, book);
          case 'pdf':
            return await extractPdfMetadata(file, book);
          case 'mp3':
          case 'm4b':
          case 'm4a':
          case 'flac':
          case 'ogg':
          case 'opus':
            return await extractAudioMetadata(file, book);
          default:
            return book;
        }
      } catch (error) {
        console.warn('Metadata extraction failed:', error);
        return book;
      }
    }

    async function extractEpubMetadata(file, book) {
      const arrayBuffer = await file.arrayBuffer();
      const zip = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
      
      try {
        const epub = await zip.default.loadAsync(arrayBuffer);
        
        // Parse container.xml
        const container = await epub.file('META-INF/container.xml').async('string');
        const parser = new DOMParser();
        const containerDoc = parser.parseFromString(container, 'text/xml');
        const opfPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
        
        if (!opfPath) return book;
        
        // Parse OPF file
        const opfContent = await epub.file(opfPath).async('string');
        const opfDoc = parser.parseFromString(opfContent, 'text/xml');
        
        // Enhanced metadata extraction
        const title = extractTextContent(opfDoc, 'title') || book.title;
        const author = extractTextContent(opfDoc, 'creator') || book.author;
        const publisher = extractTextContent(opfDoc, 'publisher') || '';
        const description = cleanHtml(extractTextContent(opfDoc, 'description') || '');
        const isbn = extractISBN(opfDoc) || '';
        const language = extractTextContent(opfDoc, 'language') || 'en';
        const publisherDate = extractTextContent(opfDoc, 'date') || '';
        const subjects = extractMultipleTextContent(opfDoc, 'subject') || [];
        const genre = subjects.slice(0, 3).join(', ') || book.genre;
        
        // Extract series information from dc:subject or meta tags
        const series = extractSeries(opfDoc) || book.series;
        
        // Extract cover with better fallback
        const coverData = await extractEpubCover(epub, opfDoc, opfPath);
        
        return {
          ...book,
          title: cleanTitle(title),
          author: cleanAuthor(author),
          publisher: publisher,
          description: description,
          isbn: isbn,
          language: language,
          year: extractYear(publisherDate) || book.year,
          genre: genre,
          series: series,
          ...coverData
        };
      } catch (error) {
        console.warn('EPUB parsing failed:', error);
        return book;
      }
    }

    function extractTextContent(doc, tagName) {
      const element = doc.querySelector(tagName);
      return element ? element.textContent.trim() : '';
    }

    function extractMultipleTextContent(doc, tagName) {
      const elements = doc.querySelectorAll(tagName);
      return Array.from(elements).map(el => el.textContent.trim()).filter(Boolean);
    }

    function extractISBN(doc) {
      // Try different ISBN identifiers
      const isbn13 = doc.querySelector('identifier[scheme="ISBN13"], identifier[opf:scheme="ISBN13"]');
      if (isbn13) return isbn13.textContent.trim();
      
      const isbn10 = doc.querySelector('identifier[scheme="ISBN10"], identifier[opf:scheme="ISBN10"]');
      if (isbn10) return isbn10.textContent.trim();
      
      const isbn = doc.querySelector('identifier[type="isbn"], identifier[id*="isbn"]');
      return isbn ? isbn.textContent.trim() : '';
    }

    function extractSeries(doc) {
      // Try to extract series from subject or meta tags
      const seriesSubject = Array.from(doc.querySelectorAll('subject'))
        .find(subject => subject.textContent.toLowerCase().includes('series'));
      
      if (seriesSubject) {
        return seriesSubject.textContent.trim();
      }
      
      // Check meta tags for series information
      const metaSeries = Array.from(doc.querySelectorAll('meta'))
        .find(meta => {
          const name = meta.getAttribute('name') || meta.getAttribute('property');
          return name && (name.toLowerCase().includes('series') || name.toLowerCase().includes('calibre:series'));
        });
      
      if (metaSeries) {
        return metaSeries.getAttribute('content') || metaSeries.textContent.trim();
      }
      
      return '';
    }

    async function extractEpubCover(epub, opfDoc, opfPath) {
      // Try multiple methods to find cover
      const coverItem = opfDoc.querySelector('item[properties="cover-image"]');
      if (coverItem) {
        const coverHref = coverItem.getAttribute('href');
        const coverPath = opfPath.replace(/[^/]*$/, '') + coverHref;
        const coverFile = epub.file(coverPath);
        if (coverFile) {
          const coverData = await coverFile.async('base64');
          return {
            coverBase64: coverData,
            coverMime: coverFile.name.split('.').pop() === 'png' ? 'image/png' : 'image/jpeg'
          };
        }
      }
      
      // Fallback: look for common cover image names
      const coverNames = ['cover.jpg', 'cover.png', 'Cover.jpg', 'Cover.png'];
      for (const coverName of coverNames) {
        const coverFile = epub.file(coverName);
        if (coverFile) {
          const coverData = await coverFile.async('base64');
          return {
            coverBase64: coverData,
            coverMime: coverFile.name.split('.').pop() === 'png' ? 'image/png' : 'image/jpeg'
          };
        }
      }
      
      return { coverBase64: null, coverMime: null };
    }

    function cleanTitle(title) {
      return title
        .replace(/\s+/g, ' ')
        .replace(/[\[\](){}]/g, '')
        .trim();
    }

    function cleanAuthor(author) {
      return author
        .replace(/\s+/g, ' ')
        .replace(/[\[\](){}]/g, '')
        .replace(/by\s+/gi, '')
        .trim();
    }

    function cleanHtml(html) {
      return html
        .replace(/<[^>]+>/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function extractYear(dateString) {
      if (!dateString) return '';
      const yearMatch = dateString.match(/(\d{4})/);
      return yearMatch ? yearMatch[1] : '';
    }

    async function extractPdfMetadata(file, book) {
      try {
        const pdfjsLib = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js');
        const pdfjsWorker = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js');
        
        pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker.default;
        
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        // Get PDF metadata
        const metadata = await pdf.getMetadata();
        
        // Extract basic PDF info
        const pdfInfo = pdf.info;
        const title = pdfInfo.title || book.title;
        const author = pdfInfo.author || book.author;
        const subject = pdfInfo.subject || '';
        const creator = pdfInfo.creator || '';
        const producer = pdfInfo.producer || '';
        const creationDate = pdfInfo.creationDate || '';
        const modificationDate = pdfInfo.modificationDate || '';
        
        // Enhanced text extraction from first few pages
        let fullText = '';
        const pagesToExtract = Math.min(3, pdf.numPages);
        
        for (let i = 1; i <= pagesToExtract; i++) {
          try {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');
            fullText += pageText + '\n';
          } catch (pageError) {
            console.warn(`Failed to extract text from page ${i}:`, pageError);
          }
        }
        
        // Try to extract title from text if not found in metadata
        let extractedTitle = title;
        if (!extractedTitle && fullText) {
          const lines = fullText.split('\n').filter(line => line.trim());
          // Look for likely title lines (longer, not all caps, not just numbers)
          for (const line of lines.slice(0, 10)) {
            const cleanLine = line.trim();
            if (cleanLine.length > 10 && 
                cleanLine.length < 100 && 
                !cleanLine.match(/^\d+$/) && 
                !cleanLine.match(/^[A-Z\s]+$/) &&
                !cleanLine.toLowerCase().includes('chapter') &&
                !cleanLine.toLowerCase().includes('page')) {
              extractedTitle = cleanLine;
              break;
            }
          }
        }
        
        // Try to extract author from text if not found in metadata
        let extractedAuthor = author;
        if (!extractedAuthor && fullText) {
          // Look for "by Author" patterns
          const byAuthorMatch = fullText.match(/(?:by|author)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2})/i);
          if (byAuthorMatch) {
            extractedAuthor = byAuthorMatch[1];
          }
        }
        
        // Extract year from dates or text
        let year = '';
        if (creationDate) {
          year = extractYear(creationDate.toString());
        } else if (fullText) {
          const yearMatch = fullText.match(/\b(19|20)\d{2}\b/);
          if (yearMatch) {
            year = yearMatch[0];
          }
        }
        
        // Clean description from first page text
        let description = '';
        if (fullText) {
          const lines = fullText.split('\n').filter(line => line.trim());
          // Take first few meaningful lines as description
          const meaningfulLines = lines.slice(0, 5).filter(line => 
            line.length > 20 && 
            !line.match(/^\d+$/) &&
            !line.toLowerCase().includes('chapter') &&
            !line.toLowerCase().includes('page')
          );
          description = meaningfulLines.join(' ').substring(0, 500);
        }
        
        return {
          ...book,
          title: cleanTitle(extractedTitle),
          author: cleanAuthor(extractedAuthor),
          publisher: producer,
          description: description,
          year: year || book.year,
          genre: subject || book.genre
        };
      } catch (error) {
        console.warn('PDF parsing failed:', error);
        return book;
      }
    }

    async function extractAudioMetadata(file, book) {
      try {
        const musicMetadata = await import('https://cdn.jsdelivr.net/npm/music-metadata-browser@2.2.10/dist/metadata.min.js');
        
        const arrayBuffer = await file.arrayBuffer();
        const metadata = await musicMetadata.parseBuffer(arrayBuffer, {
          mimeType: `audio/${file.name.split('.').pop()}`,
          size: file.size
        });
        
        // Extract cover art with better fallback
        let coverBase64 = null;
        let coverMime = null;
        const cover = metadata.common.picture;
        if (cover && cover.length > 0) {
          // Use the first available cover
          const coverData = cover[0];
          coverBase64 = btoa(String.fromCharCode(...new Uint8Array(coverData.data)));
          coverMime = coverData.format;
        }
        
        // Enhanced metadata extraction with fallbacks
        const title = metadata.common.title || book.title;
        const author = metadata.common.artist || book.author;
        const album = metadata.common.album || '';
        const genre = metadata.common.genre?.[0] || book.genre;
        const year = metadata.common.year?.toString() || book.year;
        const track = metadata.common.track?.no?.toString() || '';
        const disk = metadata.common.disk?.no?.toString() || '';
        
        // For audiobooks, try to extract narrator from comments or other fields
        let narrator = '';
        if (metadata.common.comment) {
          const comments = Array.isArray(metadata.common.comment) 
            ? metadata.common.comment 
            : [metadata.common.comment];
          
          // Look for narrator information in comments
          const narratorComment = comments.find(comment => 
            comment.toLowerCase().includes('narrator') ||
            comment.toLowerCase().includes('read by') ||
            comment.toLowerCase().includes('voiced by')
          );
          
          if (narratorComment) {
            const narratorMatch = narratorComment.match(/(?:narrator|read by|voiced by)[:\s]+(.+?)(?:[,;]|$)/i);
            if (narratorMatch) {
              narrator = narratorMatch[1].trim();
            }
          }
        }
        
        // Try to detect if this is an audiobook vs music
        const isAudiobook = detectAudiobook(metadata, file.name);
        
        // Extract technical audio information
        const format = metadata.format;
        const duration = format.duration ? Math.round(format.duration) : null;
        const bitrate = format.bitrate || null;
        const sampleRate = format.sampleRate || null;
        const channels = format.numberOfChannels || null;
        const codec = format.codec || '';
        
        // Extract additional metadata from format-specific tags
        const publisher = metadata.common.label || metadata.common.organization || '';
        const description = metadata.common.description || metadata.common.comment?.[0] || '';
        
        // Try to extract series from album or title
        let series = '';
        if (isAudiobook && album) {
          // Check if album name looks like a series
          const seriesMatch = album.match(/(.+?)(?:\s+(?:#|book)\s*(\d+))?$/i);
          if (seriesMatch) {
            series = seriesMatch[1].trim();
            if (seriesMatch[2]) {
              series += ` #${seriesMatch[2]}`;
            }
          }
        }
        
        return {
          ...book,
          title: cleanTitle(title),
          author: cleanAuthor(author),
          narrator: narrator || (isAudiobook ? author : ''), // Default to author for audiobooks
          series: series,
          year: year,
          publisher: publisher,
          genre: isAudiobook ? 'Audiobook' : genre,
          description: description,
          duration: duration,
          bitrate: bitrate,
          sampleRate: sampleRate,
          channels: channels,
          codec: codec,
          track: track,
          disk: disk,
          album: album,
          coverBase64: coverBase64,
          coverMime: coverMime
        };
      } catch (error) {
        console.warn('Audio metadata extraction failed:', error);
        return book;
      }
    }

    function detectAudiobook(metadata, fileName) {
      // Heuristics to detect if this is an audiobook
      const indicators = [
        // File name indicators
        fileName.toLowerCase().includes('audiobook'),
        fileName.toLowerCase().includes('unabridged'),
        fileName.toLowerCase().includes('abridged'),
        
        // Metadata indicators
        metadata.common.genre?.some(g => g.toLowerCase().includes('audiobook')),
        metadata.common.genre?.some(g => g.toLowerCase().includes('book')),
        metadata.common.album?.toLowerCase().includes('audiobook'),
        
        // Long duration (typical for audiobooks)
        metadata.format.duration && metadata.format.duration > 600, // 10+ minutes
        
        // Single track (common for audiobooks)
        metadata.common.track?.no === 1 && !metadata.common.disk?.no
      ];
      
      return indicators.some(Boolean);
    }

    // ===== EXTERNAL API INTEGRATION =====
    async function fetchExternalMetadata(title, author) {
      const query = `${title} ${author}`.trim();
      const results = [];
      
      try {
        // Import and use real API functions
        const { fetchGoogleBooks, fetchOpenLibrary, fetchItunes, fetchMusicBrainz } = await import('./src/apis/index.js');
        
        const [googleBooks, openLibrary, itunes, musicBrainz] = await Promise.allSettled([
          fetchGoogleBooks(query),
          fetchOpenLibrary(query),
          fetchItunes(query),
          fetchMusicBrainz(query)
        ]);
        
        if (googleBooks.status === 'fulfilled') results.push(...googleBooks.value);
        if (openLibrary.status === 'fulfilled') results.push(...openLibrary.value);
        if (itunes.status === 'fulfilled') results.push(...itunes.value);
        if (musicBrainz.status === 'fulfilled') results.push(...musicBrainz.value);
        
      } catch (error) {
        console.warn('External API fetch failed:', error);
        // Fallback to mock data if APIs fail
        return await mockSearch(query);
      }
      
      return results;
    }

    // ===== ENHANCED BOOK MANAGEMENT =====
    async function addBook() {
      // Show import options dialog
      const importMode = await showImportOptionsDialog();
      if (!importMode) return;
      
      if (importMode === 'single') {
        await handleSingleFileImport();
      } else if (importMode === 'multi') {
        await handleMultiFileImport();
      }
    }

    async function showImportOptionsDialog() {
      return new Promise((resolve) => {
        // Create modal dialog
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          background: var(--surface);
          border: 1px solid var(--border);
          border-radius: var(--radius-lg);
          padding: var(--spacing-lg);
          max-width: 400px;
          width: 90%;
        `;
        
        dialog.innerHTML = `
          <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Import Books</h3>
          <p style="margin-bottom: var(--spacing-lg); color: var(--text-secondary);">
            How would you like to import your files?
          </p>
          <div style="display: flex; flex-direction: column; gap: var(--spacing-sm);">
            <button class="btn btn-primary" id="singleImportBtn">
              üìÅ Single Files (Separate Books)
            </button>
            <button class="btn" id="multiImportBtn">
              üìö Multiple Files (Combine into Books)
            </button>
            <button class="btn" id="cancelImportBtn" style="background: var(--surface-elevated);">
              Cancel
            </button>
          </div>
        `;
        
        modal.appendChild(dialog);
        document.body.appendChild(modal);
        
        // Event listeners
        document.getElementById('singleImportBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve('single');
        });
        
        document.getElementById('multiImportBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve('multi');
        });
        
        document.getElementById('cancelImportBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve(null);
        });
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            document.body.removeChild(modal);
            resolve(null);
          }
        });
      });
    }

    async function handleSingleFileImport() {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.epub,.pdf,.mp3,.m4b,.m4a,.flac,.ogg,.opus';
      
      input.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (!files.length) return;
        
        await processFilesAsSeparateBooks(files);
      };
      
      input.click();
    }

    async function handleMultiFileImport() {
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.epub,.pdf,.mp3,.m4b,.m4a,.flac,.ogg,.opus';
      input.webkitdirectory = true; // Enable directory selection on supported browsers
      
      input.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (!files.length) return;
        
        // Group files by potential books
        const bookGroups = groupFilesIntoBooks(files);
        
        if (bookGroups.length === 1) {
          // Single book with multiple parts
          await processMultiPartBook(bookGroups[0]);
        } else {
          // Multiple books
          await processMultipleBooks(bookGroups);
        }
      };
      
      input.click();
    }

    function groupFilesIntoBooks(files) {
      // Sort files by name to ensure proper order
      const sortedFiles = files.sort((a, b) => a.name.localeCompare(b.name));
      
      const groups = [];
      const audioFormats = ['mp3', 'm4b', 'm4a', 'flac', 'ogg', 'opus'];
      
      // Try to group by directory or similar naming patterns
      const fileGroups = {};
      
      for (const file of sortedFiles) {
        const format = file.name.split('.').pop().toLowerCase();
        const isAudio = audioFormats.includes(format);
        
        let groupKey;
        
        if (isAudio) {
          // For audio files, try to group by similar base names
          const baseName = file.name.replace(/\.[^/.]+$/, '').replace(/(\d+)$/, '').trim();
          groupKey = baseName;
        } else {
          // For non-audio files, each file is its own book
          groupKey = file.name;
        }
        
        if (!fileGroups[groupKey]) {
          fileGroups[groupKey] = [];
        }
        fileGroups[groupKey].push(file);
      }
      
      // Convert to book groups
      for (const [key, groupFiles] of Object.entries(fileGroups)) {
        if (groupFiles.length === 1) {
          // Single file book
          groups.push({
            type: 'single',
            files: groupFiles,
            title: extractTitleFromFiles(groupFiles)
          });
        } else {
          // Multi-part book
          groups.push({
            type: 'multipart',
            files: groupFiles,
            title: extractTitleFromFiles(groupFiles)
          });
        }
      }
      
      return groups;
    }

    function extractTitleFromFiles(files) {
      if (files.length === 1) {
        return files[0].name.replace(/\.[^/.]+$/, '');
      }
      
      // Find common prefix in all filenames
      const names = files.map(f => f.name.replace(/\.[^/.]+$/, ''));
      const firstWords = names[0].split(' ').slice(0, 3).join(' ');
      
      // Check if this prefix is common to all files
      const commonPrefix = names.reduce((prefix, name) => {
        let common = '';
        for (let i = 0; i < Math.min(prefix.length, name.length); i++) {
          if (prefix[i] === name[i]) {
            common += prefix[i];
          } else {
            break;
          }
        }
        return common;
      });
      
      // Clean up the common prefix
      const cleanedPrefix = commonPrefix.replace(/[_-]+$/, '').trim();
      return cleanedPrefix || firstWords;
    }

    async function processFilesAsSeparateBooks(files) {
      showToast('Processing files and fetching metadata...', 'info');
      
      const processedBooks = [];
      
      for (const file of files) {
        try {
          const book = await extractMetadata(file);
          
          // Fetch external metadata
          if (book.title) {
            const externalResults = await fetchExternalMetadata(book.title, book.author);
            if (externalResults.length > 0) {
              const bestMatch = findBestMetadataMatch(externalResults, book);
              if (bestMatch) {
                await applyExternalMetadata(book, bestMatch);
              }
            }
          }
          
          processedBooks.push(book);
        } catch (error) {
          console.error('File processing failed:', error);
          showToast(`Failed to process ${file.name}`, 'error');
        }
      }
      
      state.books.unshift(...processedBooks);
      renderBooks();
      saveState();
      showToast(`Added ${processedBooks.length} separate book${processedBooks.length > 1 ? 's' : ''}`, 'success');
    }

    async function processMultiPartBook(bookGroup) {
      showToast(`Processing multi-part book: ${bookGroup.title}`, 'info');
      
      try {
        // Check if user wants to combine or keep separate
        const shouldCombine = await askCombineOption(bookGroup);
        
        if (shouldCombine) {
          const combinedBook = await combineAudioFiles(bookGroup);
          if (combinedBook) {
            state.books.unshift(combinedBook);
            renderBooks();
            saveState();
            showToast(`Created combined audiobook: ${combinedBook.title}`, 'success');
          }
        } else {
          // Process as separate parts
          await processFilesAsSeparateBooks(bookGroup.files);
        }
      } catch (error) {
        console.error('Multi-part book processing failed:', error);
        showToast('Failed to process multi-part book', 'error');
      }
    }

    async function processMultipleBooks(bookGroups) {
      showToast(`Processing ${bookGroups.length} book groups...`, 'info');
      
      const allProcessedBooks = [];
      
      for (const group of bookGroups) {
        if (group.type === 'multipart') {
          const shouldCombine = await askCombineOption(group);
          if (shouldCombine) {
            try {
              const combinedBook = await combineAudioFiles(group);
              if (combinedBook) {
                allProcessedBooks.push(combinedBook);
              }
            } catch (error) {
              console.error('Failed to combine:', group.title);
              // Fall back to separate processing
              const separateBooks = await processGroupAsSeparate(group);
              allProcessedBooks.push(...separateBooks);
            }
          } else {
            const separateBooks = await processGroupAsSeparate(group);
            allProcessedBooks.push(...separateBooks);
          }
        } else {
          // Single file
          try {
            const book = await extractMetadata(group.files[0]);
            if (book.title) {
              const externalResults = await fetchExternalMetadata(book.title, book.author);
              if (externalResults.length > 0) {
                const bestMatch = findBestMetadataMatch(externalResults, book);
                if (bestMatch) {
                  await applyExternalMetadata(book, bestMatch);
                }
              }
            }
            allProcessedBooks.push(book);
          } catch (error) {
            console.error('Failed to process:', group.files[0].name);
          }
        }
      }
      
      state.books.unshift(...allProcessedBooks);
      renderBooks();
      saveState();
      showToast(`Added ${allProcessedBooks.length} book${allProcessedBooks.length > 1 ? 's' : ''}`, 'success');
    }

    async function askCombineOption(bookGroup) {
      return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          background: var(--surface);
          border: 1px solid var(--border);
          border-radius: var(--radius-lg);
          padding: var(--spacing-lg);
          max-width: 450px;
          width: 90%;
        `;
        
        const fileCount = bookGroup.files.length;
        const totalSize = bookGroup.files.reduce((sum, file) => sum + file.size, 0);
        const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
        
        dialog.innerHTML = `
          <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Multi-Part Book Detected</h3>
          <div style="margin-bottom: var(--spacing-md); color: var(--text-secondary);">
            <p><strong>${bookGroup.title}</strong></p>
            <p>Found ${fileCount} audio files (${sizeMB} MB total)</p>
            <p>Would you like to combine them into a single file or keep them separate?</p>
          </div>
          <div style="display: flex; flex-direction: column; gap: var(--spacing-sm);">
            <button class="btn btn-primary" id="combineBtn">
              üîó Combine into Single File
            </button>
            <button class="btn" id="separateBtn">
              üìÅ Keep as Separate Files
            </button>
            <button class="btn" id="cancelBtn" style="background: var(--surface-elevated);">
              Cancel
            </button>
          </div>
        `;
        
        modal.appendChild(dialog);
        document.body.appendChild(modal);
        
        document.getElementById('combineBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve(true);
        });
        
        document.getElementById('separateBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve(false);
        });
        
        document.getElementById('cancelBtn').addEventListener('click', () => {
          document.body.removeChild(modal);
          resolve(null);
        });
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            document.body.removeChild(modal);
            resolve(null);
          }
        });
      });
    }

    async function combineAudioFiles(bookGroup) {
      try {
        // Load FFmpeg
        const { createFFmpeg } = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.0/dist/esm/index.js');
        const ffmpeg = createFFmpeg({ log: true });
        
        showToast('Loading audio processing tools...', 'info');
        await ffmpeg.load();
        
        // Create temporary file names
        const inputFiles = bookGroup.files.map((file, index) => `input${index}.${file.name.split('.').pop()}`);
        const outputFile = `${bookGroup.title.replace(/[^a-zA-Z0-9]/g, '_')}_combined.m4b`;
        
        showToast('Combining audio files...', 'info');
        
        // Write all input files to FFmpeg virtual file system
        for (let i = 0; i < bookGroup.files.length; i++) {
          const file = bookGroup.files[i];
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          await ffmpeg.writeFile(inputFiles[i], uint8Array);
        }
        
        // Create concat list file
        const concatList = inputFiles.map(file => `file '${file}'`).join('\n');
        await ffmpeg.writeFile('concat_list.txt', concatList);
        
        // Run FFmpeg to combine files
        await ffmpeg.exec([
          '-f', 'concat',
          '-safe', '0',
          '-i', 'concat_list.txt',
          '-c', 'copy',
          outputFile
        ]);
        
        // Read the combined file
        const combinedData = await ffmpeg.readFile(outputFile);
        const combinedBlob = new Blob([combinedData], { type: 'audio/m4b' });
        
        // Create a new file object for the combined audiobook
        const combinedFile = new File([combinedBlob], outputFile, { type: 'audio/m4b' });
        
        // Extract metadata from the first file (or create enhanced metadata)
        const baseBook = await extractMetadata(bookGroup.files[0]);
        baseBook.title = bookGroup.title;
        baseBook.fileName = outputFile;
        baseBook.file = combinedFile;
        baseBook.format = 'm4b';
        
        // Calculate total duration
        let totalDuration = 0;
        for (const file of bookGroup.files) {
          const book = await extractMetadata(file);
          if (book.duration) {
            totalDuration += book.duration;
          }
        }
        baseBook.duration = totalDuration;
        
        // Mark as combined audiobook
        baseBook.combined = true;
        baseBook.partCount = bookGroup.files.length;
        baseBook.originalFiles = bookGroup.files.map(f => f.name);
        
        // Fetch external metadata for the combined book
        if (baseBook.title) {
          const externalResults = await fetchExternalMetadata(baseBook.title, baseBook.author);
          if (externalResults.length > 0) {
            const bestMatch = findBestMetadataMatch(externalResults, baseBook);
            if (bestMatch) {
              await applyExternalMetadata(baseBook, bestMatch);
            }
          }
        }
        
        showToast(`Successfully combined ${bookGroup.files.length} files`, 'success');
        return baseBook;
        
      } catch (error) {
        console.error('Audio combination failed:', error);
        showToast('Failed to combine audio files. Keeping them separate.', 'error');
        return null;
      }
    }

    async function processGroupAsSeparate(group) {
      const books = [];
      for (const file of group.files) {
        try {
          const book = await extractMetadata(file);
          if (book.title) {
            const externalResults = await fetchExternalMetadata(book.title, book.author);
            if (externalResults.length > 0) {
              const bestMatch = findBestMetadataMatch(externalResults, book);
              if (bestMatch) {
                await applyExternalMetadata(book, bestMatch);
              }
            }
          }
          books.push(book);
        } catch (error) {
          console.error('Failed to process file:', file.name);
        }
      }
      return books;
    }

    async function applyExternalMetadata(book, bestMatch) {
      Object.assign(book, {
        title: bestMatch.title || book.title,
        author: bestMatch.author || book.author,
        narrator: bestMatch.narrator || book.narrator,
        publisher: bestMatch.publisher || book.publisher,
        year: bestMatch.year || book.year,
        genre: bestMatch.genre || book.genre,
        isbn: bestMatch.isbn || book.isbn,
        description: bestMatch.description || book.description,
        language: bestMatch.language || book.language
      });
      
      // Fetch cover if available
      if (bestMatch.coverUrl && !book.coverBase64) {
        try {
          const coverResponse = await fetch(bestMatch.coverUrl);
          const coverBlob = await coverResponse.blob();
          const coverBase64 = await blobToBase64(coverBlob);
          book.coverBase64 = coverBase64.split(',')[1];
          book.coverMime = coverBlob.type;
        } catch (coverError) {
          console.warn('Cover fetch failed:', coverError);
        }
      }
      
      console.log(`Enhanced metadata for "${book.title}" from ${bestMatch.source}`);
    }

    function findBestMetadataMatch(results, book) {
      if (results.length === 0) return null;
      if (results.length === 1) return results[0];
      
      // Score each result based on similarity to our book
      const scoredResults = results.map(result => {
        let score = 0;
        
        // Title similarity (most important)
        const titleSimilarity = calculateStringSimilarity(
          book.title.toLowerCase(),
          result.title.toLowerCase()
        );
        score += titleSimilarity * 40;
        
        // Author similarity
        if (book.author && result.author) {
          const authorSimilarity = calculateStringSimilarity(
            book.author.toLowerCase(),
            result.author.toLowerCase()
          );
          score += authorSimilarity * 30;
        }
        
        // Year match
        if (book.year && result.year && book.year === result.year) {
          score += 15;
        }
        
        // ISBN match (very strong indicator)
        if (book.isbn && result.isbn && book.isbn === result.isbn) {
          score += 50;
        }
        
        // Format-specific bonuses
        if (book.format === 'epub' && result.source === 'Google Books') {
          score += 10; // Google Books is good for EPUBs
        }
        if (['mp3', 'm4b', 'm4a'].includes(book.format) && result.source === 'iTunes / Audible') {
          score += 10; // iTunes is good for audiobooks
        }
        
        return { result, score };
      });
      
      // Return the highest scoring result
      scoredResults.sort((a, b) => b.score - a.score);
      
      // Only return if the best match has a decent score
      const bestMatch = scoredResults[0];
      if (bestMatch.score > 30) {
        return bestMatch.result;
      }
      
      return null;
    }

    function calculateStringSimilarity(str1, str2) {
      // Simple Levenshtein distance-based similarity
      const longer = str1.length > str2.length ? str1 : str2;
      const shorter = str1.length > str2.length ? str2 : str1;
      
      if (longer.length === 0) return 1.0;
      
      const distance = levenshteinDistance(longer, shorter);
      return (longer.length - distance) / longer.length;
    }

    function levenshteinDistance(str1, str2) {
      const matrix = [];
      
      for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
          if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[str2.length][str1.length];
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // ===== ENHANCED SEARCH =====
    async function performSearch() {
      const query = elements.searchInput.value.trim();
      if (!query) return;

      elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">Searching...</p>';
      
      try {
        const results = await fetchExternalMetadata(query, '');
        renderSearchResults(results);
      } catch (error) {
        elements.searchResults.innerHTML = '<p style="color: var(--error);">Search failed. Please try again.</p>';
      }
    }

    function renderSearchResults(results) {
      if (results.length === 0) {
        elements.searchResults.innerHTML = '<p style="color: var(--text-secondary);">No results found.</p>';
        return;
      }

      const html = results.map(result => `
        <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--spacing-md); margin-bottom: var(--spacing-sm);">
          <h4 style="margin-bottom: var(--spacing-xs);">${escapeHtml(result.title)}</h4>
          <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-xs);">
            ${escapeHtml(result.author || 'Unknown Author')} ‚Ä¢ ${result.year || 'Unknown Year'}
          </p>
          <p style="color: var(--text-muted); font-size: 0.75rem; margin-bottom: var(--spacing-sm);">
            Source: ${escapeHtml(result.source)}
          </p>
          <button class="btn btn-primary" style="margin-top: var(--spacing-sm);" onclick="applySearchResult(${JSON.stringify(result).replace(/"/g, '&quot;')})">
            Use This Metadata
          </button>
        </div>
      `).join('');

      elements.searchResults.innerHTML = html;
    }

    // Apply search result to current book (placeholder)
    window.applySearchResult = function(result) {
      showToast('Metadata selected! Add a book first to apply this metadata.', 'info');
    };

    // ===== ADVANCED FEATURES =====
    
    // Book Editor/Viewer
    function openBook(book) {
      showBookEditor(book);
    }

    function showBookEditor(book) {
      const modal = createBookEditorModal(book);
      document.body.appendChild(modal);
      
      // Animate in
      requestAnimationFrame(() => {
        modal.classList.add('show');
      });
    }

    function createBookEditorModal(book) {
      const modal = document.createElement('div');
      modal.className = 'book-editor-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeBookEditor(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Edit Book</h2>
            <button class="btn btn-icon" onclick="closeBookEditor(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="book-cover-section">
              <div class="cover-preview">
                ${book.coverBase64 ? 
                  `<img src="data:${book.coverMime};base64,${book.coverBase64}" alt="Cover">` :
                  `<div class="cover-placeholder">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                      <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                    </svg>
                  </div>`
                }
              </div>
              <button class="btn" onclick="changeBookCover(${book.id})">Change Cover</button>
            </div>
            <div class="book-form">
              <div class="form-group">
                <label>Title</label>
                <input type="text" id="edit-title" value="${escapeHtml(book.title || '')}">
              </div>
              <div class="form-group">
                <label>Author</label>
                <input type="text" id="edit-author" value="${escapeHtml(book.author || '')}">
              </div>
              <div class="form-group">
                <label>Narrator (Audiobooks)</label>
                <input type="text" id="edit-narrator" value="${escapeHtml(book.narrator || '')}">
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Series</label>
                  <input type="text" id="edit-series" value="${escapeHtml(book.series || '')}">
                </div>
                <div class="form-group">
                  <label>Year</label>
                  <input type="number" id="edit-year" value="${escapeHtml(book.year || '')}">
                </div>
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Publisher</label>
                  <input type="text" id="edit-publisher" value="${escapeHtml(book.publisher || '')}">
                </div>
                <div class="form-group">
                  <label>Genre</label>
                  <input type="text" id="edit-genre" value="${escapeHtml(book.genre || '')}">
                </div>
              </div>
              <div class="form-group">
                <label>ISBN</label>
                <input type="text" id="edit-isbn" value="${escapeHtml(book.isbn || '')}">
              </div>
              <div class="form-group">
                <label>Language</label>
                <select id="edit-language">
                  <option value="en" ${book.language === 'en' ? 'selected' : ''}>English</option>
                  <option value="es" ${book.language === 'es' ? 'selected' : ''}>Spanish</option>
                  <option value="fr" ${book.language === 'fr' ? 'selected' : ''}>French</option>
                  <option value="de" ${book.language === 'de' ? 'selected' : ''}>German</option>
                  <option value="it" ${book.language === 'it' ? 'selected' : ''}>Italian</option>
                  <option value="ja" ${book.language === 'ja' ? 'selected' : ''}>Japanese</option>
                  <option value="zh" ${book.language === 'zh' ? 'selected' : ''}>Chinese</option>
                </select>
              </div>
              <div class="form-group">
                <label>Description</label>
                <textarea id="edit-description" rows="4">${escapeHtml(book.description || '')}</textarea>
              </div>
              ${book.duration ? `
              <div class="audio-info">
                <h4>Audio Information</h4>
                <div class="audio-stats">
                  <span>Duration: ${formatDuration(book.duration)}</span>
                  <span>Bitrate: ${book.bitrate || 'N/A'} kbps</span>
                  <span>Sample Rate: ${book.sampleRate || 'N/A'} Hz</span>
                  <span>Channels: ${book.channels || 'N/A'}</span>
                </div>
              </div>
              ` : ''}
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn" onclick="closeBookEditor(this)">Cancel</button>
            <button class="btn btn-primary" onclick="saveBookChanges(${book.id})">Save Changes</button>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeBookEditor = function(element) {
      const modal = element.closest('.book-editor-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    window.changeBookCover = function(bookId) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
          const base64 = await blobToBase64(file);
          const book = state.books.find(b => b.id === bookId);
          if (book) {
            book.coverBase64 = base64.split(',')[1];
            book.coverMime = file.type;
            renderBooks();
            saveState();
            showToast('Cover updated', 'success');
            closeBookEditor(document.querySelector('.book-editor-modal .btn'));
          }
        }
      };
      input.click();
    };

    window.saveBookChanges = function(bookId) {
      const book = state.books.find(b => b.id === bookId);
      if (!book) return;

      book.title = document.getElementById('edit-title').value;
      book.author = document.getElementById('edit-author').value;
      book.narrator = document.getElementById('edit-narrator').value;
      book.series = document.getElementById('edit-series').value;
      book.year = document.getElementById('edit-year').value;
      book.publisher = document.getElementById('edit-publisher').value;
      book.genre = document.getElementById('edit-genre').value;
      book.isbn = document.getElementById('edit-isbn').value;
      book.language = document.getElementById('edit-language').value;
      book.description = document.getElementById('edit-description').value;

      renderBooks();
      saveState();
      closeBookEditor(document.querySelector('.book-editor-modal .btn'));
      showToast('Book updated successfully', 'success');
    };

    function formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }

    // Batch Operations
    function showBatchOperations() {
      const modal = createBatchModal();
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('show'));
    }

    function createBatchModal() {
      const modal = document.createElement('div');
      modal.className = 'batch-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeBatchModal(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Batch Operations</h2>
            <button class="btn btn-icon" onclick="closeBatchModal(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="batch-section">
              <h3>Export Options</h3>
              <button class="btn" onclick="exportAsJSON()">Export as JSON</button>
              <button class="btn" onclick="exportAsCSV()">Export as CSV</button>
              <button class="btn" onclick="exportCoversOnly()">Export Covers Only</button>
            </div>
            <div class="batch-section">
              <h3>Metadata Operations</h3>
              <button class="btn" onclick="batchFetchMissing()">Fetch Missing Metadata</button>
              <button class="btn" onclick="batchUpdateCovers()">Update All Covers</button>
              <button class="btn btn-danger" onclick="batchClearMetadata()">Clear All Metadata</button>
            </div>
            <div class="batch-section">
              <h3>Library Management</h3>
              <button class="btn" onclick="findDuplicates()">Find Duplicates</button>
              <button class="btn" onclick="organizeBySeries()">Organize by Series</button>
              <button class="btn btn-danger" onclick="batchDelete()">Batch Delete</button>
            </div>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeBatchModal = function(element) {
      const modal = element.closest('.batch-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    // Batch Operations Implementation
    window.exportAsCSV = function() {
      const headers = ['Title', 'Author', 'Format', 'Year', 'Publisher', 'Genre', 'ISBN', 'Language'];
      const csv = [headers.join(',')];
      
      state.books.forEach(book => {
        const row = [
          `"${book.title || ''}"`,
          `"${book.author || ''}"`,
          book.format,
          `"${book.year || ''}"`,
          `"${book.publisher || ''}"`,
          `"${book.genre || ''}"`,
          `"${book.isbn || ''}"`,
          book.language || 'en'
        ];
        csv.push(row.join(','));
      });
      
      downloadFile(csv.join('\n'), 'library.csv', 'text/csv');
      showToast('Library exported as CSV', 'success');
    };

    window.exportCoversOnly = function() {
      const booksWithCovers = state.books.filter(book => book.coverBase64);
      if (booksWithCovers.length === 0) {
        showToast('No books with covers found', 'warning');
        return;
      }
      
      booksWithCovers.forEach((book, index) => {
        const dataUrl = `data:${book.coverMime};base64,${book.coverBase64}`;
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = `${book.title || book.fileName}_cover.${book.coverMime.split('/')[1]}`;
        link.click();
      });
      
      showToast(`Exported ${booksWithCovers.length} covers`, 'success');
    };

    window.batchFetchMissing = async function() {
      const booksNeedingMetadata = state.books.filter(book => 
        !book.author || !book.description || (!book.coverBase64 && book.title)
      );
      
      if (booksNeedingMetadata.length === 0) {
        showToast('All books have complete metadata', 'info');
        return;
      }
      
      showToast(`Updating ${booksNeedingMetadata.length} books...`, 'info');
      
      for (const book of booksNeedingMetadata) {
        try {
          const results = await fetchExternalMetadata(book.title, book.author);
          if (results.length > 0) {
            const bestMatch = results[0];
            Object.assign(book, {
              title: bestMatch.title || book.title,
              author: bestMatch.author || book.author,
              publisher: bestMatch.publisher || book.publisher,
              year: bestMatch.year || book.year,
              genre: bestMatch.genre || book.genre,
              isbn: bestMatch.isbn || book.isbn,
              description: bestMatch.description || book.description
            });
            
            if (bestMatch.coverUrl && !book.coverBase64) {
              try {
                const coverResponse = await fetch(bestMatch.coverUrl);
                const coverBlob = await coverResponse.blob();
                const coverBase64 = await blobToBase64(coverBlob);
                book.coverBase64 = coverBase64.split(',')[1];
                book.coverMime = coverBlob.type;
              } catch (e) {
                console.warn('Cover fetch failed for', book.title);
              }
            }
          }
        } catch (error) {
          console.warn('Metadata fetch failed for', book.title);
        }
      }
      
      renderBooks();
      saveState();
      showToast('Batch metadata update complete', 'success');
    };

    window.findDuplicates = function() {
      const duplicates = [];
      const seen = new Map();
      
      state.books.forEach(book => {
        const key = `${book.title.toLowerCase()}-${book.author?.toLowerCase() || ''}`;
        if (seen.has(key)) {
          duplicates.push({ book, original: seen.get(key) });
        } else {
          seen.set(key, book);
        }
      });
      
      if (duplicates.length === 0) {
        showToast('No duplicates found', 'info');
      } else {
        showToast(`Found ${duplicates.length} potential duplicates`, 'warning');
        // TODO: Show duplicates management modal
      }
    };

    window.batchDelete = function() {
      if (confirm('Are you sure you want to delete all books? This cannot be undone.')) {
        state.books = [];
        renderBooks();
        saveState();
        showToast('All books deleted', 'success');
        closeBatchModal(document.querySelector('.batch-modal .btn'));
      }
    };

    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Advanced Search
    function showAdvancedSearch() {
      const modal = createAdvancedSearchModal();
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('show'));
    }

    function createAdvancedSearchModal() {
      const modal = document.createElement('div');
      modal.className = 'search-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeSearchModal(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Advanced Search</h2>
            <button class="btn btn-icon" onclick="closeSearchModal(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="search-form">
              <div class="form-group">
                <label>Title</label>
                <input type="text" id="search-title" placeholder="Search in titles...">
              </div>
              <div class="form-group">
                <label>Author</label>
                <input type="text" id="search-author" placeholder="Search in authors...">
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Format</label>
                  <select id="search-format">
                    <option value="">All Formats</option>
                    <option value="epub">EPUB</option>
                    <option value="pdf">PDF</option>
                    <option value="mp3">MP3</option>
                    <option value="m4b">M4B</option>
                    <option value="flac">FLAC</option>
                    <option value="ogg">OGG</option>
                  </select>
                </div>
                <div class="form-group">
                  <label>Year</label>
                  <input type="number" id="search-year" placeholder="Year">
                </div>
              </div>
              <div class="form-group">
                <label>Genre</label>
                <input type="text" id="search-genre" placeholder="Search in genres...">
              </div>
              <div class="form-group">
                <label>ISBN</label>
                <input type="text" id="search-isbn" placeholder="ISBN...">
              </div>
              <div class="form-group">
                <label>
                  <input type="checkbox" id="search-has-cover"> Has cover image
                </label>
              </div>
              <div class="form-group">
                <label>
                  <input type="checkbox" id="search-missing-meta"> Missing metadata
                </label>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn" onclick="closeSearchModal(this)">Cancel</button>
            <button class="btn btn-primary" onclick="performAdvancedSearch()">Search</button>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeSearchModal = function(element) {
      const modal = element.closest('.search-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    window.performAdvancedSearch = function() {
      const title = document.getElementById('search-title').value.toLowerCase();
      const author = document.getElementById('search-author').value.toLowerCase();
      const format = document.getElementById('search-format').value;
      const year = document.getElementById('search-year').value;
      const genre = document.getElementById('search-genre').value.toLowerCase();
      const isbn = document.getElementById('search-isbn').value;
      const hasCover = document.getElementById('search-has-cover').checked;
      const missingMeta = document.getElementById('search-missing-meta').checked;
      
      const results = state.books.filter(book => {
        if (title && !book.title.toLowerCase().includes(title)) return false;
        if (author && !book.author?.toLowerCase().includes(author)) return false;
        if (format && book.format !== format) return false;
        if (year && book.year !== year) return false;
        if (genre && !book.genre?.toLowerCase().includes(genre)) return false;
        if (isbn && !book.isbn?.includes(isbn)) return false;
        if (hasCover && !book.coverBase64) return false;
        if (missingMeta && (book.author && book.description)) return false;
        return true;
      });
      
      closeSearchModal(document.querySelector('.search-modal .btn'));
      
      // Show results
      if (results.length === 0) {
        showToast('No books match your search criteria', 'info');
      } else {
        showToast(`Found ${results.length} matching books`, 'success');
        // Temporarily filter the view
        const originalBooks = state.books;
        state.books = results;
        renderBooks();
        
        // Add reset button
        const resetBtn = document.createElement('button');
        resetBtn.className = 'btn btn-secondary';
        resetBtn.textContent = 'Reset Search';
        resetBtn.style.margin = 'var(--spacing-md)';
        resetBtn.onclick = () => {
          state.books = originalBooks;
          renderBooks();
          resetBtn.remove();
        };
        elements.bookGrid.parentNode.insertBefore(resetBtn, elements.bookGrid);
      }
    };

    // Statistics Dashboard
    function showStatistics() {
      const stats = calculateStatistics();
      const modal = createStatsModal(stats);
      document.body.appendChild(modal);
      requestAnimationFrame(() => modal.classList.add('show'));
    }

    function calculateStatistics() {
      const total = state.books.length;
      const formats = {};
      const years = {};
      const authors = {};
      const withCovers = state.books.filter(book => book.coverBase64).length;
      const withMetadata = state.books.filter(book => book.author && book.description).length;
      const audiobooks = state.books.filter(book => ['mp3', 'm4b', 'm4a', 'flac', 'ogg', 'opus'].includes(book.format)).length;
      
      state.books.forEach(book => {
        formats[book.format] = (formats[book.format] || 0) + 1;
        if (book.year) years[book.year] = (years[book.year] || 0) + 1;
        if (book.author) authors[book.author] = (authors[book.author] || 0) + 1;
      });
      
      return {
        total,
        formats,
        years: Object.entries(years).sort((a, b) => b[0] - a[0]).slice(0, 10),
        topAuthors: Object.entries(authors).sort((a, b) => b[1] - a[1]).slice(0, 10),
        withCovers,
        withMetadata,
        audiobooks,
        completionRate: Math.round((withMetadata / total) * 100)
      };
    }

    function createStatsModal(stats) {
      const modal = document.createElement('div');
      modal.className = 'stats-modal';
      modal.innerHTML = `
        <div class="modal-backdrop" onclick="closeStatsModal(this)"></div>
        <div class="modal-content">
          <div class="modal-header">
            <h2>Library Statistics</h2>
            <button class="btn btn-icon" onclick="closeStatsModal(this)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="modal-body">
            <div class="stats-grid">
              <div class="stat-card">
                <h3>${stats.total}</h3>
                <p>Total Books</p>
              </div>
              <div class="stat-card">
                <h3>${stats.withCovers}</h3>
                <p>With Covers</p>
              </div>
              <div class="stat-card">
                <h3>${stats.completionRate}%</h3>
                <p>Metadata Complete</p>
              </div>
              <div class="stat-card">
                <h3>${stats.audiobooks}</h3>
                <p>Audiobooks</p>
              </div>
            </div>
            
            <div class="stats-section">
              <h3>Format Distribution</h3>
              ${Object.entries(stats.formats).map(([format, count]) => 
                `<div class="stat-bar">
                  <span class="stat-label">${format.toUpperCase()}</span>
                  <div class="stat-progress">
                    <div class="stat-fill" style="width: ${(count / stats.total) * 100}%"></div>
                  </div>
                  <span class="stat-value">${count}</span>
                </div>`
              ).join('')}
            </div>
            
            <div class="stats-section">
              <h3>Top Authors</h3>
              ${stats.topAuthors.map(([author, count]) => 
                `<div class="author-stat">
                  <span>${escapeHtml(author)}</span>
                  <span>${count} books</span>
                </div>`
              ).join('')}
            </div>
          </div>
        </div>
      `;
      return modal;
    }

    window.closeStatsModal = function(element) {
      const modal = element.closest('.stats-modal');
      modal.classList.remove('show');
      setTimeout(() => modal.remove(), 300);
    };

    // Update settings to include new options
    function updateSettings() {
      const settingsContent = document.querySelector('#settingsTab .settings-scroll');
      if (settingsContent) {
        const newSections = `
          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Advanced Features</h3>
            <button class="btn" id="batchBtn" style="margin-bottom: var(--spacing-sm);">Batch Operations</button>
            <button class="btn" id="advancedSearchBtn" style="margin-bottom: var(--spacing-sm);">Advanced Search</button>
            <button class="btn" id="statsBtn" style="margin-bottom: var(--spacing-sm);">Library Statistics</button>
          </div>
          
          <div style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <h3 style="margin-bottom: var(--spacing-md);">Import/Export</h3>
            <button class="btn" id="importBtn" style="margin-bottom: var(--spacing-sm);">Import Library</button>
            <button class="btn" id="exportJsonBtn" style="margin-bottom: var(--spacing-sm);">Export as JSON</button>
            <button class="btn" id="exportCsvBtn" style="margin-bottom: var(--spacing-sm);">Export as CSV</button>
          </div>
        `;
        
        settingsContent.insertAdjacentHTML('beforeend', newSections);
        
        // Add event listeners for new buttons
        document.getElementById('batchBtn').addEventListener('click', showBatchOperations);
        document.getElementById('advancedSearchBtn').addEventListener('click', showAdvancedSearch);
        document.getElementById('statsBtn').addEventListener('click', showStatistics);
        document.getElementById('importBtn').addEventListener('click', importLibrary);
        document.getElementById('exportJsonBtn').addEventListener('click', exportLibrary);
        document.getElementById('exportCsvBtn').addEventListener('click', exportAsCSV);
      }
    }

    function importLibrary() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            const text = await file.text();
            const imported = JSON.parse(text);
            if (Array.isArray(imported)) {
              state.books = [...state.books, ...imported];
              renderBooks();
              saveState();
              showToast(`Imported ${imported.length} books`, 'success');
            } else {
              showToast('Invalid file format', 'error');
            }
          } catch (error) {
            showToast('Import failed', 'error');
          }
        }
      };
      input.click();
    }

    // Add modal styles
    const modalStyles = `
      .book-editor-modal, .batch-modal, .search-modal, .stats-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .book-editor-modal.show, .batch-modal.show, .search-modal.show, .stats-modal.show {
        opacity: 1;
      }
      
      .modal-backdrop {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
      }
      
      .modal-content {
        position: relative;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        max-width: 90vw;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: var(--shadow-xl);
      }
      
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border);
      }
      
      .modal-body {
        padding: var(--spacing-md);
        overflow-y: auto;
        max-height: 60vh;
      }
      
      .modal-footer {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: flex-end;
        padding: var(--spacing-md);
        border-top: 1px solid var(--border);
      }
      
      .book-cover-section {
        text-align: center;
        margin-bottom: var(--spacing-lg);
      }
      
      .cover-preview {
        width: 120px;
        height: 160px;
        margin: 0 auto var(--spacing-sm);
        border-radius: var(--radius-md);
        overflow: hidden;
        background: var(--bg-tertiary);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .cover-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .cover-placeholder {
        color: var(--text-muted);
      }
      
      .book-form {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
      }
      
      .form-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
      }
      
      .form-group label {
        font-weight: 500;
        color: var(--text-secondary);
        font-size: 0.875rem;
      }
      
      .form-group input,
      .form-group select,
      .form-group textarea {
        padding: var(--spacing-sm);
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: inherit;
      }
      
      .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-md);
      }
      
      .audio-info {
        background: var(--bg-tertiary);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        margin-top: var(--spacing-md);
      }
      
      .audio-stats {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-md);
        font-size: 0.875rem;
        color: var(--text-secondary);
      }
      
      .batch-section {
        margin-bottom: var(--spacing-lg);
      }
      
      .batch-section h3 {
        margin-bottom: var(--spacing-sm);
        color: var(--text-secondary);
      }
      
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
      }
      
      .stat-card {
        background: var(--bg-tertiary);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        text-align: center;
      }
      
      .stat-card h3 {
        font-size: 2rem;
        font-weight: 700;
        color: var(--primary);
        margin-bottom: var(--spacing-xs);
      }
      
      .stat-card p {
        color: var(--text-secondary);
        font-size: 0.875rem;
      }
      
      .stats-section {
        margin-bottom: var(--spacing-lg);
      }
      
      .stats-section h3 {
        margin-bottom: var(--spacing-md);
        color: var(--text-secondary);
      }
      
      .stat-bar {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-xs);
      }
      
      .stat-label {
        min-width: 60px;
        font-size: 0.875rem;
      }
      
      .stat-progress {
        flex: 1;
        height: 8px;
        background: var(--bg-tertiary);
        border-radius: var(--radius-full);
        overflow: hidden;
      }
      
      .stat-fill {
        height: 100%;
        background: var(--primary);
        transition: width 0.3s ease;
      }
      
      .stat-value {
        min-width: 30px;
        text-align: right;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }
      
      .author-stat {
        display: flex;
        justify-content: space-between;
        padding: var(--spacing-xs) 0;
        border-bottom: 1px solid var(--border);
      }
      
      .author-stat:last-child {
        border-bottom: none;
      }
      
      @media (max-width: 768px) {
        .form-row {
          grid-template-columns: 1fr;
        }
        
        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
        
        .modal-content {
          max-width: 95vw;
          margin: var(--spacing-md);
        }
      }
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.textContent = modalStyles;
    document.head.appendChild(styleSheet);

    // ===== START APP =====
    init();
    updateSettings();
  </script>
</body>
</html>
